---
layout: post
title: "Informacion para AYDS"
subtitle: 'Mis apuntes de Analisis y Diseno De Software del semestre 2021-1, Espero les sirva'
date: 2021-04-06 12:00:00
author: "TheusZero"
header-img: "images/post/PythonAutoayuda/solarized-wallpaper-python.png"
catalog: true
comments: true
tags:
    - Programacion
    - USM
    - Tareas
---

## Clases

**clase 2**

#### Requisitos
Aplicados al software, cumplir con estos requisitos es fundamental
>> Descripciones de lo que el sistema debe/deberia hacer
> 
>> Capacidades y condiciones a las que el sistema debe adherir
> 
> Dos tipos:
> 
>> Funcionales
> 
>> Extra funcionales (No Funcionales)

**Funcionales**

Son las tareas faciles de identificar que en el software deben ser funcionalidades o servicios que el sistema debe o deberia realizar.

Funcionalidad: entrada de los datos / comportamiento de los mismos, con la funcionalidad del sistema / salida o resultado final para el usuario

>> Pueden existir limitaciones puestas por el usuario (reestricciones)
>
> ![](/TheusZero/images/post/ads/1.png)
 
Los requisitos extra-funcionales son importantes, son un gran impacto a nivel de la arquitectura y puede que haga la diferencia a la hora de que el usuario elija tu software

#### Requerimientos

Es un levantamiento o elicitacion (captar) de requerimientos.

> Aqui participan
>> Usuario: es Quien Utiliza el software. Una persona o una comunidad
> 
>> Cliente: Quien Paga por el software (inversionista)
> 
>> Stakeholder: Concepto generico para persona o institucion que tiene algun interes en el proyecto y que puede influir en las deciciones que se toman para el proyecto.
> 
>> Analista: Quien debe caracterizar y precisar lo que los usuarios o clientes requieren
>
> ![](/TheusZero/images/post/ads/2.png)

#### Diagrama de contexto

Nos sirve para graficar todo antes de ponernos a programas, es una forma de traducir los requerimientos y los requisitos, es una manera para desenvolvernos y comprender antes de programar.

> El software vive en un contexto
>> interactua con su entorno = interactua con funcionalidades de su entorno.
> 
>> Provee funcionalidades a su entorno | Necesita funcionalidades de su entorno
> ej: Necesitar cosas de la base de datos, ingresar valores a x lugar.

> primera aproximacion del sistema dentro de su entorno
> 
> Podemos identificar con quien se relaciona el sistema
>> Pero no nos dice la forma, no nos dice como conseguir algo (que servicios tecnicos tendra)

> Definir las fronteras o limites del sistema y como este interactua con su entorno.
>> estos limites pueden estar claramente definidos | Puede definirse en etapas tempranas, a base de criterios de funcionalidad.
>
>> Reconocer o identificar cuales seran funcionalidades automatizadas o manuales, ya que de esa forma sabremos que sera lo que el usuario ingresara en el software.

> Impacto
>> La toma de decisiones generan costos y beneficios
> 
> ![](/TheusZero/images/post/ads/4.png)
> 
> ![](/TheusZero/images/post/ads/3.png)
> 
>> Ambas opciones tienen costos y beneficios
> 
> ![](/TheusZero/images/post/ads/5.png)

#### Modelo de dominio

es una interpretacion del negocio, este mismo tiene un alcance

> tenemos que ser capaces de:
>> Comprender el contexto de negocio
> 
>> identificar conceptos clave
> 
>> entender como los conceptos se relacionan

El modelo de dominio es un diagrama que ilsutra clases (objetos) significativas de un dominio de problema particular para el analista y el disenador.
Su objetivo es visualizar y comprender la relacion de los conceptos que se manejan en el dominio del problema 

![](/TheusZero/images/post/ads/6.png)

![](/TheusZero/images/post/ads/7.png)

![](/TheusZero/images/post/ads/8.png)

> ejemplo: aqui faltan las asociaciones y atributos.
> ![](/TheusZero/images/post/ads/9.png)

> Atributos:
>> Valores que caracterizan una clase (soy persona, mi nombre es Robert)
> 
>> una clase puede tener multiples atributos.
>
> ![](/TheusZero/images/post/ads/10.png)

> UML :
>
> ![](/TheusZero/images/post/ads/11.png)
>
> Es relevante?: SI, pero depende de en que contexto es relevante. ya que si se necesita un software del horoscopo, este atributo seria muy relevante

> Modelos de Dominio: **Atributos simple**
>
> ![](/TheusZero/images/post/ads/12.png)
>> No utiliza claves foraneas (como una base de datos)

**Clase 3**
![](/TheusZero/images/post/ads/13.png)

![](/TheusZero/images/post/ads/14.png)

> **en resumen modelo de dominio:** es una representacion garfica de los conceptos y sus atributos, y sus relaciones cen el dominio del problema.

> Asociaciones ya tributos son elementos secundarios
>> el esfuerzo debe estar en encontrar clases, conceptos. 

#### Multiplicidad Modelo de dominio

![](/TheusZero/images/post/ads/15.png)

![](/TheusZero/images/post/ads/16.png)

![](/TheusZero/images/post/ads/17.png)

**Resumen Modelo de Dominio**

El modelo de dominio es un **diagrama que ilustra clases (objetos) significativas de un dominio** de problema
particular para el analista y el diseñador. Un modelo de domino es una
**representación gráfica de los conceptos**, sus atributos y sus relaciones en el
dominio del problema

**El objetivo es Visualizar y comprender la relación de los conceptos** que se manejan en
el domino del problema.

> Elementos:
>> Clases conceptuales: Representan objetos del dominio, pero aquellos relevantes para su comprensión
>
> Atributos: Valores que caracterizan una clase (pueden ser múltiples)
> 
> Asociaciones: Relación entre conceptos del modelo de dominio. (son bidireccionales)

> Multiplicidad asociaciones:
>> Rol: las clases en cada extremo de la asociación (A – B).
> 
>> Cada rol, tiene una multiplicidad.
> 
>> Multiplicidad: Define cuantas instancias de la clase A, pueden ser asociadas a instancias de la clase B. Se expresan por rangos o valores acotados.
>
> ![](/TheusZero/images/post/ads/20.png)

> Consideraciones
>> ![](/TheusZero/images/post/ads/21.png)


>> Un modelo de domino es una representación gráfica de los conceptos,
>> sus atributos y sus relaciones en el dominio del problema.
> 
>> Asociaciones y atributos son elementos secundarios
>>> El esfuerzo debe estar en encontrar clases, conceptos y  deben agregarse en la medida que aporten al entendimiento del dominio.

**Ejercicio**

[Ejemplo del profe](https://github.com/wormaza/EjemploModeloDominio)

![](/TheusZero/images/post/ads/18.png)

![](/TheusZero/images/post/ads/19.png)



#### Historias de usuarios

Necesitamos comunicar los requisitos desde el negocio (quien necesita el
software) hacia el equipo de desarrollo (quienes lo construyen).

> **Podemos especificar requisitos puros**. Indican una operación del sistema, podrían tender a una documentación detallada.
>> ![](/TheusZero/images/post/ads/22.png)

> **Casos de uso**: Podemos enfocarlos como la interacción entre el usuario y el sistema. Podrían tender a una documentación más detallada.
>> ![](/TheusZero/images/post/ads/23.png)

> **Historias deUsuario (HU)**
>> Descripción concisa por escrito de un requisito funcional
> 
>> Proporciona valor para un usuario
> 
>> Basada en los objetivos de usuario (los usuarios interactúan con el sistema para el lograrlos): De ahí su nombre
>
>> Técnica vinculada a procesos ágiles y al tratamiento iterativo de los requisitos. (Fomenta la comunicación)
>
>> Una Historia de Usuario(HU) se enfoca en una necesidad del usuario.
> 
>> ![](/TheusZero/images/post/ads/24.png)
> 
>> ![](/TheusZero/images/post/ads/25.png)
>
> Deben ser completa y lo suficientemente grande para proporcionar valor al usuario.
>> Pero lo suficientemente pequeña para poder ser abordada en una iteración.
>
> Deben estar centradas en el usuario
>> Normalmente las personas escriben historias de usuario que son demasiado centradas en aspectos de los componentes o sistemas.

> Generalmente, se escriben en tarjetas (o cartas).
> 
> Los detalles de la HU nacen de la conversación entre los stakeholders (consenso).
> 
> Deben contener un criterio de aceptación que permita confirmar que la HU fue implementada de forma correcta.

> Estructura:
>> ![](/TheusZero/images/post/ads/26.png)

> Estructura tipo: Título
>> Breve oración que resume la necesidad de la HU.
>>> Debe ser específica para que se puede diferenciar de otras HU
>> Puede ir acompañada de un identificador.

> Estructura tipo: Descripción
>> Identifica el tipo de usuario, lo que quiere realizar y el valor que entrega:
>>> ![](/TheusZero/images/post/ads/27.png)
>
>>> ![](/TheusZero/images/post/ads/28.png)
>
>>> ![](/TheusZero/images/post/ads/29.png)
> 
>>> ![](/TheusZero/images/post/ads/30.png)


> Estructura tipo: Criterios de aceptación
>> Permiten validar si lo diseñado/construido está en conformidad con lo que desea el cliente.
>
>> Una técnica común es utilizar la estructura Given-When-Then (Dado-CuandoEntonces).
>
>> Una HU puede tener más de un criterio de aceptación.
>
>> ![](/TheusZero/images/post/ads/31.png)
> 
>> ![](/TheusZero/images/post/ads/32.png)
>
>> ![](/TheusZero/images/post/ads/33.png)

> Estructura tipo: Conversación
>> Los detalles de la historia vienen a través de conversaciones con quienes toman decisiones
>
>> Sirven de antecedente para justificar la descripción y criterios de validación
>>> ![](/TheusZero/images/post/ads/34.png)

**Criterio Invest:** (criterios a seguir)
![](/TheusZero/images/post/ads/36.png)

**Ejercicio:** Tomando como base el escenario del supermercado, escriba una HU que
contenga descripción y criterios de aceptación:
![](/TheusZero/images/post/ads/35.png)

>> **RESUMEN:**
> No describen el como se implementará.
>
> Desde la perspectiva del usuario (Como X yo quiero …)
>
> Fomenta la comunicación  Lograr consenso.
>
>  Permiten realizar estimaciones a través de “story points”
>>  Los story points son una medida del esfuerzo requerido para realizar una
>> historia de usuario, basándose en términos de complejidad, tamaño, nivel
>> de incertidumbre y riesgos asociados.

> USER STORY MAPPING
> ![](/TheusZero/images/post/ads/37.png)

#### Diagrama de Secuencia

Un diagrama de secuencia del sistema ilustra eventos (*) de entrada y
salida relacionados con el sistema en discusión:

![](/TheusZero/images/post/ads/38.png)

Importa el que hacen, y NO el como lo hace: entidades como caja
negra.

• Perspectiva dinámica de análisis y descripción del sistema

![](/TheusZero/images/post/ads/39.png)

![](/TheusZero/images/post/ads/40.png)

![](/TheusZero/images/post/ads/41.png)

> OBJETO
>> ![](/TheusZero/images/post/ads/42.png)
>
>> ![](/TheusZero/images/post/ads/43.png)

Tambien podemos tener multiples objetos que reciben el mismo
nombre.

![](/TheusZero/images/post/ads/44.png)

> ESTEREOTIPOS
>> ![](/TheusZero/images/post/ads/45.png)
>
> ![](/TheusZero/images/post/ads/46.png)
>> ![](/TheusZero/images/post/ads/47.png)

![](/TheusZero/images/post/ads/48.png)

![](/TheusZero/images/post/ads/49.png)

> MENSAJES e INTERACCION
>> Tambien podemos encontrar diferentes tipos de mensajes y formas en que los participantes interactúan:
>
> Mensaje síncrono: La entidad que envía el mensaje espera mientras la entidad que recibe el mensaje termine el procesamiento y envíe su respuesta (la más común)
>
> Mensaje asíncrono: La entidad que envía el mensaje continua su ejecución sin esperar respuesta
>
> ![](/TheusZero/images/post/ads/50.png)
>
> Mensaje encontrado: Refiere al tipo de mensaje que no muestra quien lo envia, esto podria
> significar que no se conoce el remitente o no es importante para el entendimiento de la interaccion que se esta describiendo.
> ![](/TheusZero/images/post/ads/53.png)
>> no se sabe quien lo gatillo, solo lo recibo.
> Mensaje autoenviado (visto casi siempre en la base de datos).
> ![](/TheusZero/images/post/ads/54.png)
> 
> Mensaje condicional: mensaje que se envia solo si se cumple una condicion, esta es gatillada por los corchetes, entonces, el mensaje solo se envia si se cumple la condicion generada.
> ![](/TheusZero/images/post/ads/55.png)
>> ![](/TheusZero/images/post/ads/56.png)
>> ![](/TheusZero/images/post/ads/57.png)
> Mensajes secuenciales
>> ![](/TheusZero/images/post/ads/58.png)
> ojo con los asteriscos

![](/TheusZero/images/post/ads/59.png)

![](/TheusZero/images/post/ads/60.png)

**Clase7**

#### diagrama de estado

> transiciones y cambios de estado al momento de hacer una accion.
>> ![](/TheusZero/images/post/ads/61.png)

#### diagrama de actividad

> escenario: se busca reflejar el como se desarrolla alguna actividad de interes por ejemplo:
>> ![](/TheusZero/images/post/ads/62.png)


#### softgoal

> escenario donde toma vital  relevancia la toma de desiciones y el que camino tomaras para desarrollar software
> identificando los pro-contra de la toma de desiciones.
>> ![](/TheusZero/images/post/ads/63.png)
>> ![](/TheusZero/images/post/ads/65.png)
>> ![](/TheusZero/images/post/ads/64.png)
>> ![](/TheusZero/images/post/ads/66.png)
> Pero que pasa si:
>> ![](/TheusZero/images/post/ads/67.png)

![](/TheusZero/images/post/ads/68.png)
![](/TheusZero/images/post/ads/69.png)
![](/TheusZero/images/post/ads/70.png)
![](/TheusZero/images/post/ads/71.png)

**Clase 8**

#### Frameworks

![](/TheusZero/images/post/ads/73.png)
![](/TheusZero/images/post/ads/74.png)
![](/TheusZero/images/post/ads/75.png)
![](/TheusZero/images/post/ads/76.png)
![](/TheusZero/images/post/ads/77.png)
![](/TheusZero/images/post/ads/78.png)
![](/TheusZero/images/post/ads/79.png)
![](/TheusZero/images/post/ads/80.png)
![](/TheusZero/images/post/ads/81.png)

#### MODELO VISTA CONTROLADOR

Un patrón describe un problema recurrente y entrega una propuesta
de solución genérica aplicable a este problema recurrente.

![](/TheusZero/images/post/ads/89.png)


> Modelo
>> Contiene métodos para hacer CRUD2
>> a una fuente de datos
>
>> Típicamente se encarga también de gestionar la lógica del dominio de la
>> aplicación web

> Vista
>> Representa la interfaz gráfica de usuario de la aplicación web
> 
>> Utiliza datos proporcionados por el modelo para representarlos a través de la
>> interfaz de usuario
>
>> Típicamente, para web, se implementa a través de HTML y CSS

> Controlador
>> Procesa peticiones HTTP
>>
>> Define el comportamiento de una aplicación web
>> 
>> Es intermediario entre vista y modelo, recuperando datos desde el modelo y se
>> los entrega a la vista
>> 
>> Puede utilizar e invocar métodos de múltiples modelos

![](/TheusZero/images/post/ads/90.png)

> HMVC
>> Se le conoce como Hierarchical Model-View-Controller (HMVC)
> ![](/TheusZero/images/post/ads/91.png)

> MVP
>> El concepto de controlador se identifica como presentador
>
>> El controlador (presentador) es el encargado de la comunicación.
>
>> En esta variante el controlador (presentador) no tiene lógica de negocio: solo
>> invoca las funcionalidades requeridas al modelo.
>
>> Se le conoce como Model-View-Presenter (MVP)
> ![](/TheusZero/images/post/ads/92.png)


> Cumple con la definición que hemos dado de un patrón
>> Describe un problema recurrente
> 
>> Entrega una propuesta de solución genérica aplicable a este problema recurrente

> Cada uno de los componentes de MVC puede ser apoyado con otros patrones

> La esencia en MVC es la separación de componentes de un sistema según su
> propósito

> MVC no especifica cómo se debe implementar dicha separación

> MVC favorece la mantenibilidad del código y permite delegar responsabilidades
> en el desarrollo

> Evita introducir defectos en el software producidos por la poca legibilidad de un
> código que consolida todos los aspectos del sitio en una misma clase

#### Object-relational mapping (ORM)

Técnica usada para interpretar datos desde un sistema de base de datos
relacional a objetos de una aplicación

Típicamente, se le llama ORM al componente de software que usa esta técnica

Utilizando un ORM, se puede consultar la base de datos sin la necesidad de
escribir las consultas de forma directa

![](/TheusZero/images/post/ads/93.png)

Considera un conjunto de funcionalidades que traducen los requerimientos a
consultas de base de datos

Vincula los atributos de los objetos con las entradas de una base de datos
relacional

Se debe considerar que las bases de datos relacionales tiene diseño tabular,
mientras que los objetos tienden a tener estructuras jerárquicas, por ende, para
aplicar ORM se deben considerar las transformaciones necesarias para la
representación de los datos

> Ventajas
> 
> Facilidad de uso
> 
> Abstracción de la base de datos usada
>
> Facilita el mantenimiento del código al separar la capa de datos
> 
> Las implementaciones pueden proporcionan mecanismos de seguridad para
> prevenir accesos malintencionados a las bases de datos
> 
> Desventajas
> 
> Impacto de rendimiento al trabajar con grandes volúmenes de datos
> 
> Requiere aprender a escribir operaciones usando algún componente de ORM

#### Active Record

Active Record es una forma de implementar ORM

Gestiona la persistencia de datos y los métodos asociados para la utilización y
recuperación de los mismos

> Utilidad
>> Proporciona una representación de un modelos y sus datos asociados
>> 
>> Proporciona una representación de las asociaciones entre modelos
>> 
>> Proporciona una representación de las jerarquías de herencia entre esos modelos
>> 
>> Permite la validación de los modelos antes de que se hagan persistentes en la
>> base de datos
>> 
>> Permite operaciones de bases de datos a través de métodos específicos que
>> manipulan objetos

![](/TheusZero/images/post/ads/94.png)

Si bien los datos se mapean con bases de datos relacionales, nada impide que
los datos sean almacenados en otro tipo de bases de datos

Active Record funciona bien cuando las operaciones son de tipo CRUD y otras
similares

Cuando la complejidad de las operaciones aumenta, Active Record puede
volverse difícil de usar

Active Record se acopla fuertemente al diseño de la base de datos

#### Data Mapper

Los objetos y las bases de datos relacionales tienen diferentes mecanismos para
estructurar los datos

Muchas partes de un objeto, como las colecciones y la herencia, no son
directamente modelables en las bases de datos relacionales

Cuando se construye un sistema con mucha lógica de negocio, es valioso
mantener estas reglas ordenadas para organizar mejor los datos y el
comportamiento que conllevan

Si un componente ORM basa su diseño en objetos en memoria que se
relacionan demasiado con la estructura de la base de datos, los cambios en uno
tienden a complicarse en el otro

El patrón Data Mapper propone la utilización de una capa de software
intermedia que separa los objetos en memoria de la base de datos

Su responsabilidad es transferir datos entre las dos capas y también aislarlas

> Con el patrón Data Mapper los objetos
>> No necesitan saber que hay una base de datos presente
> 
>> No necesitan manejar consultas a la base de datos
> 
>> No necesitan conocimiento del esquema de la base de datos
> ![](/TheusZero/images/post/ads/95.png)
> ![](/TheusZero/images/post/ads/96.png)
> ![](/TheusZero/images/post/ads/97.png)

La separación entre el dominio y el origen de datos es la función principal de un
Data Mapper

Existen muchas formas de construir las capas que realizan el mapping

Al momento de requerir actualización de datos, se solicita al mapper que
extraiga dichos datos desde un objeto y los almacene en la fuente de datos

Los mappers necesitan una variedad de estrategias para manejar clases que se
convierten en múltiples campos, clases que tienen múltiples tablas, clases con
herencia y clases que gestionan la conexión de objetos

Las estrategias varían de acuerdo el conocimiento que se tenga del origen de
datos

Un sistema puede tener uno o más Data Mapper implementados

En un sistema de gran escala puede ser excesivo tener solamente un mapper
que tenga mucho métodos de hacia la base de datos, por lo que tiene sentido
dividir estos métodos bajo algún criterio de agrupación en múltiples mappers

La principal oportunidad para utilizar el patrón Data Mapper es cuando se desea
que el esquema de base de datos y las clases/objetos evolucionen de forma
independiente

Facilitar el diseño de un sistema que debe implementar estrictas reglas de
negocio

Si se desea minimizar el impacto de la base de datos en los objetos (y
viceversa). De hecho, al usar Data Mapper, los objetos ni siquiera necesitan
saber que hay una base de datos presente

>> Uso De acuerdo al tipo de sistema
> Un sistema en desarrollo cuyo
> propósito es principalmente realizar
> CRUD de datos, Active Record es la
> solución preferida ya que permite de
> forma rápida y sencilla realizar estas
> tareas
> 
> Para satisfacer estrictas reglas y
> procedimientos de una empresa, en
> un sistema en desarrollo, el patrón
> Data Mapper podría ser una mejor
> opción. El patrón impondrá ciertas
> restricciones al tratar con datos y
> persistencia, y permitirá encapsular
> esas reglas de negocio dentro de sus
> entidades sin involucrar la base de
> datos

>> Uso De acuerdo al ecosistema tecnológico
> Si se está construyendo un sistema en
> un dominio nuevo Active Record es lo
> recomendable ya que en un principio
> no se conocen en detalle las reglas de
> negocio que van a ser más relevantes
> para el sistema
> 
> Si se requiere integrar una aplicación
> en una organización madura y con
> sistemas ya establecidos, Data
> Mapper es lo aconsejable
> considerando que la organización ya
> dispone de reglas y procesos bien
> definidos

#### Repository

En muchas aplicaciones la lógica del negocio accede a los datos de diversas
fuentes como bases de datos, servicios web, etc

> Acceder a los datos directamente puede causar (entre otros):
>> Introducir defectos en los datos con mayor frecuencia
> 
>> Incapacidad para probar fácilmente la lógica del negocio de forma aislada de las
>> dependencias externas

Un sistema con un modelo de dominio complejo se beneficia de una capa que
aísla los objetos del dominio de los detalles del código de acceso de la base de
datos (como la proporcionada por el patrón Data Mapper)

La aislación se vuelve más necesaria cuando hay una gran cantidad de clases de
dominio, consultas complejas o que buscan acceder a una gran cantidad de
datos

Un Repositorio es un objeto que imita una colección

Un Repositorio es un medio entre el dominio y las capas de acceso a datos,
actuando como una colección de objetos de dominio

Los objetos construyen las especificaciones de consulta de forma declarativa y
las envían al repositorio

De manera conceptual, un Repositorio encapsula el conjunto de objetos y las
respectivas operaciones sobre los datos realizadas sobre estos, proporcionando
una vista orientada a objetos de la capa de persistencia.

Agregar esta capa ayuda a minimizar la lógica duplicada de consultas

El patrón Repository separa la lógica que recupera datos y la asigna a una
entidad del modelo de la lógica del negocio

Nos ayuda a mejorar la mantenibilidad y la capacidad de prueba, la lógica de
negocio se preocupa del negocio en sí, y no de operaciones de bajo nivel

![](/TheusZero/images/post/ads/98.png)

![](/TheusZero/images/post/ads/99.png)

![](/TheusZero/images/post/ads/100.png)

Comparaciones, ¿Active Record o Repository?

![](/TheusZero/images/post/ads/101.png)

> Comparaciones, ¿Data Mapper o Repository?
> 
> En términos de aislamiento y capacidad de hacer pruebas, el patrón Data
> Mapper es similar al patrón Repository
> 
> El repositorio se basa en los fundamentos del patrón Data Mapper, pero agrega
> una capa adicional de abstracción sobre la capa de mapping donde se concentra
> el código de las consultas a la base de datos

> Comparaciones ¿Cuando usar el patrón Repository?
> 
> Cuando se desea acceder a la fuente de datos desde muchas ubicaciones y se
> desea aplicar lógica y reglas de acceso consistentes y administradas
> centralmente
> 
> Cuando se debe mejorar la capacidad de mantenimiento y compresión del
> código al separar la lógica de negocio de la lógica de acceso a datos o servicios

#### Foreign Key Mapping

En un sistema, muchos objetos se relacionan entre sí

Para almacenar estos objetos en la base de datos, es vital conservar las
referencias

Haciendo las cosas más complicadas: un objeto puede almacenar una colección
de objetos que se referencian entre sí

![](/TheusZero/images/post/ads/102.png)

#### Association Table Mapping

Los objetos pueden utilizar campos con múltiples valores de manera sencilla.
Por ejemplo, utilizando colecciones

Las bases de datos relacionales por lo general no disponen de estas
características y están restringidas a utilizar campos que permiten sólo un valor
(existen excepciones como campos tipo JSON en MySQL y JSONB en
PostgreSQL, entre otros, que permiten representar una estructura completa a
modo de objeto JSON como campo de una tabla)

Si se desea mapear una asociación de objetos 1:M se puede utilizar Foreign Key
Mapping, pero en una relación M:N no se puede representar de esta forma,
porque existiría un problema en la utilización de la clave foránea para
representar múltiples valores

![](/TheusZero/images/post/ads/103.png)

#### Single Table Inheritance

Las bases de datos relacionales no tienen soporte para herencia, por lo que
cuando se mapea de objetos a bases de datos se debe considerar cómo
representar estructuras de herencia en la base de datos relacional

Cuando se mapea a una base de datos relacional, se debe evitar un diseño que
implique múltiples tablas para representar la herencia, ya que en la práctica, al
hacer múltiples consultas tipo JOIN se verá afectado el rendimiento del sistema

![](/TheusZero/images/post/ads/104.png)

#### Class Table Inheritance

Las bases de datos relacionales no tienen soporte para herencia, pero usar un
enfoque basado en representaciones de herencia en una única tabla puede ser
confuso

Se requieren estructuras de bases de datos que mapeen claramente los objetos y
permitan vincular cualquier elemento de la estructura de herencia

![](/TheusZero/images/post/ads/105.png)

![](/TheusZero/images/post/Proba/17-28.png)


#### Page Controller

El patrón MVC a menudo se enfoca principalmente en la separación entre el
modelo y la vista, mientras presta menos atención al controlador

En algunos escenarios, la separación entre el controlador y la vista es menos
crítica y a menudo se omite

En algunas aplicaciones la vista y el controlador están separados inherentemente
porque la presentación ocurre en el navegador del cliente, mientras que el
controlador es parte de la aplicación del lado del servidor

Considerando el uso de MVC para separar los componentes de la interfaz de
usuario de la lógica del negocio

La aplicación que se está construyendo no es compleja, las páginas son
dinámicas y la lógica de navegación entre ellas es sencilla

¿Qué alternativas existen para estructurar un controlador destinado a
aplicaciones web medianamente complejas, que permitan reutilización y
flexibilidad mientras evitan la duplicación de código?

![](/TheusZero/images/post/ads/106.png)

El controlador recibe una solicitud de la página, extrae cualquier dato relevante,
invoca cualquier actualización al modelo y reenvía la solicitud a la vista

La vista, a su vez, depende del modelo para la recuperación de datos

Se crea un controlador para cada página de la aplicación web

> Beneficios
>> Simplicidad
> 
>> Debido a que cada página web dinámica es manejada por un controlador
>> específico, los controladores tienen que tratar sólo con un alcance limitado y
>> pueden ser simples
>
>> Desempeño
> 
>> No existen cuellos de botella al utilizar distintos controladores a través del
>> sistema web ya que se disminuyen los recursos compartidos
>
>> Reutilización
> 
>> La creación de una clase controlador reduce la duplicación de código y permite
>> reutilizar código entre los controladores de página. Se debe tener presente que
>> en este tipo de controladores la incorporación de funcionalidades globales en un
>> sitio web, podría significar un incremento en la duplicación de código en cada
>> Page Controller, lo cual dista de ser un beneficio

#### Front Controller

En un sitio web complejo hay muchos elementos similares que se debe atender
cuando se gestiona una petición (seguridad, vistas específicas para usuarios
específicos, etc.)

Si se gestiona esto en un controlador por página, mucho comportamiento debe
duplicarse a nivel de código. Además, es difícil cambiar este comportamiento en
tiempo de ejecución

¿Que alternativas existen para estructurar un controlador para aplicaciones web
complejas, donde se pueda tener reutilización y flexibilidad mientras se evita la
duplicación de código?

![](/TheusZero/images/post/ads/107.png)

Front Controller consolida todas las peticiones en un único objeto

Front Controller usualmente delega peticiones a Page Controllers de cada
página. Muchas implementaciones usan ambos tipos de controladores

>> Beneficios
> Simplificación
>> Un Front Controler simplifica el desarrollo cuando la lógica de las peticiones es
>> complicada y no parece apropiado gestionarla con un Page Controller
> 
> Eficiencia
>> La centralización minimiza la duplicación de código, como sería de implementar
>> funcionalidades globales utilizando Page Controllers. Por otra parte la
>> centralización facilita el refactoring
> 
> Optimización
>> Se facilita la optimización del comportamiento y la extensión de funcionalidades
>> en runtime (e.g. internacionalización, autenticación, etc.)

#### Transform View

![](/TheusZero/images/post/ads/108.png)

Transform View recupera datos y genera código HTML según plantillas
predefinidas que se aplican a los datos procesados

Al realizar peticiones a las capas de persistencia se obtienen todos los datos
necesarios para desplegar en una página, pero sin formatearlos apropiadamente
para la capa de presentación de la página. El rol de la vista en MVC es
desplegar esos datos en una página

En MVC, Transform View se encarga de realizar las transformaciones necesarias
recibiendo como input los datos provenientes del modelo, y como output, el
código HTML que compone la vista

Template View se orienta solamente al código de presentación final mientras
que Transform View realiza transformaciones para cada dato recibido. Por
ejemplo: Se puede implementar como un loop que recorre cada elemento de
entrada y lo transforma de acuerdo a un esquema predefinido


Transform View mitiga las desventajas de Template View y es fácil preocuparse
solamente de las transformaciones necesarias para generar HTML, evitando
lógica del dominio externa en la vista

![](/TheusZero/images/post/ads/109.png)

![](/TheusZero/images/post/ads/110.png)




## Ejercicios y Preguntas Certamenes

#### Preguntas de concepto

> En un modelo de dominio es importante a˜nadir toda la informacion
> posible aunque esta pareciera no ser relevante para el dominio del
> problema.
>> FALSO: En un modelo de dominio se debe detallar solo la informacion
>> mas relevante para el problema

>A traves de la utilizacion de MVC se favorece la mantenibilidad del
>codigo.
>> VERDADERO.

>Un diagrama de secuencia ilustra las respuestas del sistema para un
>conjunto de historias de usuario.
>> FALSO: Un diagrama de secuencia ilustra, para un escenario particular,
>> las respuestas del sistema asociadas a una historia de usuario.

> Un patron de diseno se compone generalmente de 3 elementos:
> contexto, problema recurrente, y solucion generica.
>> VERDADERO

> Una historia de usuario se centra en describir la prespectiva del
> usuario, lo que implica que el negocio es el dominante en las
> conversaciones.
>> SE REFUTA:
> 
>> I Si arguye en contra: 2 pts.
> 
>> I Si explica que las HDU se utilizan para lograr consenso: 2 pts.
> 
>> I Si explica que el objetivo principal de las HDU es evitar que el negocio
>> o desarrollo sean dominantes: 3 pts.
> 
>> I Si explica que por m´as que las HDU se centren en las perspectiva del
>> usuario, es trabajo del equipo de desarrollo el cuidar que ninguna de las
> 
>> partes involucradas sea dominante: 3 pts.

> Los Frameworks y patrones se encuentran en un nivel de abstraccion distinto.
>> SE AFIRMA:
> 
>> Si arguye a favor
> 
>> Si detecta que los Frameworks son m´as concretos que los patrones
> 
>> Si explica que los Frameworks son una t´ecnica que reusa tanto dise˜no
>> como codigo, mientras que los patrones se centran solo en el dise˜no
> 
>> Si explicar que generalmente los Frameworks incorporan varios patrones
>> en su implementacion

> Al realizar un modelo de dominio el esfuerzo debe centrarse en
> encontrar conceptos relevantes.
>> SE AFIRMA:
>> Si arguye a favor
> 
>> Si explica que un modelo de dominio las asociaciones y los atributos
>> son elementos secundarios
> 
>> Si explica que en un modelo de dominio es esencial comprender la
>> relacion de los conceptos que se manejan en el contexto del problema:
> 
>> Si explica que la frase es el pilar principal de un modelo de dominio

> En una historia de usuario, una buena especificacion de conversacion
> debe satisfacer el criterio INVEST.
>> FALSO: El criterio INVEST se utilizar para elaborar historias de
>> usuarios, y aplica a la historia de forma global, no a su conversacion.

> El diagrama de secuencia permite analizar el sistema desde una
> perspectiva estatica, mientras que el modelo de dominio permite
> realizar un analisis dinamico de las entidades que describen el diseno
> de un sistema.
>> FALSO: El diagrama de secuencia analiza el sistema desde una
>> perspectiva dinamica. El modelo de dominio no describe el diseno de
>> un sistema, si no que identifica entidades que se interrelacionan para
>> comprender el entorno de un problema especıfico. Es decir, el modelo
>> de dominio describe el “universo” conocido en terminos del problema a
>> resolver

> User Story Mapping es una tecnica que permite organizar las historias
> de usuario por tipo, funcionalidad y complejidad de desarrollo.
>> FALSO: Esta tecnica permite organizar las historias de usuario por
>> orden de realizacion y funcionalidad, no haciendo referencia alguna a la
>> complejidad de desarrollo.

> En un sistema web basado en MVC, el modelo es el componente que
> gestiona las peticiones HTTP.
>> FALSO: El componente MVC que gestiona las peticiones HTTP es el
>> controlador.

> Un requisito extra-funcional corresponder a un conjunto de
> caracterısticas opcionales que debe exhibir un sistema.
>> Se Refuta: Un requisito extra-funcional es una propiedad sistemica la
>> cual puede ser priorizada de igual forma que un requisito funcional, sin
>> embargo no significa que estos sean opcionales. Recordar que el no
>> cumplimiento de un requisito extra-funcional relevante para el usuario
>> puede dejar en desuso un sistema, debido a que su omision podrıa
>> traducirse en problemas en la operacion del mismo. Ej: Un avion
>> comercial debe movilizar pasajeros de un punto a otro (requisito
>> funcional). Si no exhibe estabilidad durante el vuelo (requisito
>> extra-funcional), el riesgo de accidente se incrementa con todas las
>> consecuencias que esto significa, tanto para el avi´on como para los
>> pasajeros

> MVC ayuda en la separacion de responsabilidades, pero no especifica
> como llevar a cabo esa separacion, dejando espacio para el uso de
> patrones que aborden problemas mas especıficos.
>> Se afirma: MVC es un patron que permite separar las responsabilidades
>> en tres partes fundamentales: Modelo, Vista y Controlador. Sin
>> embargo aquella separacion no especifica como abordar problemas mas
>> especıficos, tal como persistir y consultar datos de una BD,
>> generar vistas para los diferentes perfiles, “mapping” entre tablas y
>> objetos, coordinacion de todos los elementos de MVC presentes en
>> un sistema.
>> Notar que para cada uno de estos elementos existen patrones
>> especıficos que abordan problemas concretos, que seg´un el contexto
>> presentan ventajas y desventajas comparativas.

> En un sistema web basado en MVC pueden existir paginas que solo
> implementan algunos de los tres elementos de dicho patron.
>> Se Afirma: MVC es un patron que permite separar responsabilidades en
>> tres elementos: Modelo, Vista y Controlador. Acorde al tipo de dominio
>> y problema, algunas paginas web no necesitan implementar todos los
>> elementos MVC. Por ejemplo, si es un dominio sencillo y el problema
>> no es sofisticado (sistemas con paginas web estaticas), quizas se puede
>> prescindir del modelo, considerando el hecho que las paginas contienen
>> contenido estatico cuyos datos se insertan directamente en el HTML.
>> Por otro lado, en componentes de back-end que solo realizan
>> operaciones, podrıa bastar con implementar una configuracion de
>> modelo y controlador, sin necesidad de incorporar interfaces de usuario
>> (vistas).

> El proposito de un modelo de dominio es ilustrar con precision el
> diseno de un sistema, identificando las entidades involucradas y
> especificando como se relacionan entre sı.
>> Se refuta: El modelo de dominio no ilustra el diseno de un sistema, sino
>> que se enfoca en identificar las entidades involucradas y relacionarlas
>> entre sı, en el contexto de un problema especıfico. Un error frecuente
>> en la elaboracion de modelos de dominio es tratarlos como modelos de
>> datos. Un modelo de datos corresponder a un artefacto de diseno de un
>> sistema, mientras que un modelo de dominio se centra en comprender
>> el entorno involucrado en el problema; es decir, un modelo de dominio
>> emerge de un ejercicio de analisis para comprender el problema.

> El propósito del modelo de dominio es representar los requisitos extra-funcionales
> de un sistema de software.
>> R: Falso. Un modelo de dominio es una representación gráfica de los conceptos,
>> sus atributos y relaciones en el contexto del dominio del problema.

>Un stakeholder es una persona u organización que tiene interés en un proyecto y que
>puede influir en las decisiones que se tomen.
>>R: Verdadero.

> Un buen diagrama de secuencia debe satisfacer el criterio INVEST.
>> R: Falso. El criterio INVEST es utilizado para elaborar historias de usuario.

> Una historia de usuario es una descripción concisa, por escrito, de un requisito
> funcional del sistema de software que proporciona valor para un usuario.
>> R: Verdadero

> Data Mapper propone la utilización de una capa de software intermedia que separe
> los objetos en memoria de la base de datos.
>> R: Verdadero

> Los patrones MVC y Data Mapper resuelven el mismo problema.
>> R: Falso. El patrón MVC es un patrón de arquitectura de software que separa las
>> partes constituyentes de una aplicación en 3 elementos (Modelo, Vista, Controlador)
>> y el patrón Data Mapper es un patrón de persistencia que resuelve la complejidad de
>> transferir datos entre dos esquemas distintos.

>Toda aplicación empresarial debería utilizar el patrón MVC.
>> R: El alumno debe considerar los siguientes puntos en su fundamento:
>> - Las aplicaciones empresariales tienen distintos desafíos tecnológicos que
>>   involucran manipulación de datos, interfaces gráficas de usuario, accesos
>>   concurrentes, entre otros.
> 
>> - Todo lo anterior puede significar un problema si coexisten todos estos
>>   elementos sin ningún tipo de separación a nivel de código/componentes
>>   (código difícil de mantener, código espagueti susceptible de defectos, etc)
> 
>> - Una forma de solucionar este problema es utilizando MVC, que separa según
>>   capas de acceso a datos (modelos), interfaces de usuario (vistas), y gestión de
>>   las peticiones hacia los recursos (controladores). En MVC, los componentes
>>   interactúan de acuerdo a la finalidad que posee cada uno; por ejemplo: un
>>   controlador invoca a métodos de un modelo para hacer CRUD en ciertos datos,
>>   el modelo proporciona esos datos a la vista que finalmente se despliega en el
>>   navegador. Un usuario interactúa con un controlador (si accede al recurso
>>   utilizando una URI de forma directa) o con una vista (que proporcionará
>>   elementos que permitirán invocar o enviar datos a un controlador)
> 
>> - Toda esta lógica de interacciones es utilizada por MVC para abordar este
>>   problema separando de forma estructural las responsabilidades de cada capa
>>   (presentación, lógica del negocio, etc).
> 
>> - Si bien MVC resuelve el problema, es sólo una forma de solucionarlo; dado
>>   que la solución consiste en organizar datos, interfaces de usuario, acceso a
>>   recursos, sesiones, entre otros, de acuerdo a una lógica que limite
>>   responsabilidades favoreciendo el mantenimiento y la calidad del software;
>>   por tal razón no es contractual que todas las aplicaciones empresariales
>>   utilicen MVC, sino que pueden utilizar patrones o propuestas alternativas que
>>   gestionen las capas/elementos de forma apropiada, para evitar el problema
>>   descrito anteriormente

> La utilización de ORM favorece el desarrollo de software.
>> R: El alumno debe considerar los siguientes puntos en su fundamento:
>> La utilización de ORM tiene ventajas reconocidas para el desarrollo de software,
>> como por ejemplo, la abstracción del acceso a los datos, incluso sin importar su
>> origen, facilitar el mantenimiento del software (etapa crítica de un proceso de
>> desarrollo de software) al no crear dependencias de consultas con SGBD específicos
>> que podrían variar a través del tiempo; manipulación de los datos con orientación a
>> objetos, lo que resulta familiar y menos susceptible de requerir entrenamiento
>> adicional respecto a distintas formas de adquisición de datos que pudiese requerir la
>> aplicación; y en algunas implementaciones, separación de la lógica del dominio
>> respecto del acceso a los datos. Todo lo anterior es beneficioso para el desarrollo de
>> software.

> La elección de componentes ORM basados en Data Mapper o Active Record,
> depende del contexto del proyecto.
>> R: El alumno debe considerar los siguientes puntos en su fundamento:
>> El contexto es un factor clave a la hora de elegir algún patrón de persistencia. Por
>> ejemplo, en situaciones en las que se utilizan múltiples orígenes de datos para hacer
>> CRUD en un sistema es recomendable la utilización de Data Mapper. En el caso de
>> Active Record, su utilización es recomendable cuando la lógica del negocio y las
>> consultas son relativamente sencillas, considerando además, que se debe conocer el
>> esquema de la fuente de datos.
>> En ocasiones, la decisión depende de la elección de la tecnología que se utilizará en
>> el proyecto, específicamente del framework. Es decir, se elige un framework acorde
>> al contexto del proyecto y se acepta el componente ORM que viene de facto con el
>> framework, ya sea por la cohesión que tiene con el mismo o por la compatibilidad a
>> futuro (muchas veces el ORM del framework evoluciona conjuntamente con el
>> mismo).

> Los diagramas de secuencia y de comunicación son equivalentes.
>> R: El alumno debe considerar los siguientes puntos en su fundamento:
>> Ambos ilustran la manera en que los objetos interactúan entre sí, sin embargo, el de
>> comunicación se enfoca en la relación entre los objetos y el de secuencia en el
>> tiempo en que ocurren los eventos. Es posible transformar un diagrama de secuencia
>> en un diagrama de comunicación (y viceversa) traduciendo a la sintaxis respectiva
>> según la especificación de cada uno de los diagramas.

>Un buen diseño del componente ORM se basa en objetos en memoria que poseen
>todo el conocimiento respecto a la estructura de la fuente de datos.
>> Falso: La técnica ORM sugiere que los objetos en memoria deben tener poca o
>> nula información respecto a la estructura de la fuente de datos.

> En un modelo de dominio es importante añadir toda la información posible aunque
> esta pareciera no ser relevante para el dominio del problema.
>> Falso: En un modelo de dominio se debe detallar solo la información más
>> relevante para el problema.

> Un diagrama de secuencia ilustra las respuestas del sistema para un conjunto de
> historias de usuario.
>> Falso: Un diagrama de secuencia ilustra, para un escenario particular, las
>> respuestas del sistema asociadas a una historia de usuario.

> Un patron de diseño se compone generalmente de 3 elementos: contexto, problema
> recurrente, y solución genérica.
>> Verdadero

> A través de la utilización de MVC se favorece la mantenibilidad del codigo.
>> Verdadero.

> Los componentes ORM son de gran utilidad al trabajar con grandes volúmenes de
> datos.
>> Falso: La frase hace referencia a una de las principales desventajas de ORM.

#### Objetivos y criterios de exito

>> ![](/TheusZero/images/post/ads/82.png)

#### Modelo de contexto

> diagrama de contexto podemos identificar a los agentes que participan
>> ![](/TheusZero/images/post/ads/83.png)

#### Modelo de dominio

> ![](/TheusZero/images/post/ads/85.png)
>> ![](/TheusZero/images/post/ads/84.png)

#### Diagrama de secuencia

Ilustra eventos de entrada y salida relacionados con el sistema en discusion. Se generan despues de analizar e inspeccionar las historias de usuario.

>> ![](/TheusZero/images/post/ads/86.png)
> Notaciones
>> Mensaje sıncronos: esperar a respuesta.
> 
>> Mensaje asıncrono: no es necesario esperar respuesta.
> ![](/TheusZero/images/post/ads/87.png)
> 
> ![](/TheusZero/images/post/ads/88.png)

#### Historia de usuario

> Titulo:
>>  comunicación desde el profesor jefe a alumnos y apoderados

> Descripción
>> **Yo Como** Profesor Jefe **Quiero** ser capaz de comunicar información importante recibida
>> desde la directiva del establecimiento, entregar información que sea especifica para el curso completo y mandar mensajes particulares y/o privados a un alumno o apoderado. **Para**
>> que los alumnos sean informados sobre anuncios de carácter importante recibidos desde
>> la directiva y para que sean instruidos sobre alguna situación en particular y privada, como
>> lo es la entrega de notas o en caso más vital, un contacto estrecho.

> Criterios de aceptación
>> 1. **Dado** el profesor jefe del curso, **cuando** este recibe mensajes importantes de la directiva del establecimiento, como lo es el director, **entonces** debe ser capaz de informar
>>    a los alumnos y/o apoderados.
> 
>> 2. Dado el profesor jefe del curso, cuando este desee informar de manera privada a un
>>    alumno o apoderado en específico sobre alguna situación en particular, entonces el
>>    sistema debe ser capaz de generar o mantener un canal o buzón para hacer entrega
>>    de estos mensajes.
> 
>> 3. Dado el profesor jefe del curso, cuando este necesite hacer la entrega del informe
>>    de notas a un alumno particular, debido a que las notas del alumno son privadas entonces el sistema deberá ser capaz de proporcionar esta entrega de notas de forma
>>    privada para que el alumno y/o apoderado estén informados de la situación académica.
> 
>> 4. Dado el profesor jefe del curso, cuando este necesite enviar o recibir información
>>    desde los otros docentes, es decir, desde los otros profesores entonces el sistema
>>    deberá ser capaz de proporcionar esta comunicación entre profesores.
   

> Conversacion
>> El Profesor jefe de un curso necesita comunicarse con los alumnos para informarles sobre avisos importantes recibidos desde la directiva y de la misma forma, poder informar
>>sobre sus notas de manera privada, también sera capaz de enviar información a los otros
>>profesores en caso de existir un hecho particular que lo amerite. De esta forma el sistema será capaz de realizar estos envíos y recibos de información para que cumpla con el
>>funcionamiento de establecer una comunicación directa con los alumnos y docentes.

## Reuniones clientes

#### Primera reunion

>>> **Escenario prensencial**
> dinamica propia de cada comunidad educativa (como realizaran las actividades, como las fechas de las pruebas)
>
> Comunicacion fluida e inmediata (los avisos se dan en la misma clase o despues de la misma, mucho mas instantanea)
> 
> Muchos participantes (alumnos y directivos, profesores y profesores jefe)
> 
> muchos niveles (informacion que debe ser transimita a todo el colegio, otra a solo el curso y otra a solo una asignatura)

> Reunion de apoderados
>> profesor jefe comunica noticias del establecimiento, del curso y otras cosas.
> 
>> notas de cada alumno

> Sala de clase
>> cada profesor en su asignatura comunica al curso las actividades que van a realizar
>>> Tareas, pruebas, material de estudio

>>> **Escenario actual**
> COVID
> 
> Actividades semi-presenciales y remotas
> 

> En que podemos ayudar
>> generar un medio de comunicacion entre los diversos actores de la comunidad educativa

> Posibles escenarios

> Escenario 1: sala de clase
>> profesor de la asignatura debe enviar un aviso a los alumnos del curso que esten en su asignautra, no existen canales oficiales y cuando se da por clase quiza no todos esten presente falta comunicacion
> 
>> profesor debe comunicarse con un alumno


> Escenario 2: consejo de curso
>> profesor jefe enviar a todos sus alumnos informacion que recibe desde la directiva.
> 
>> avisos del establecimiento
> 
>> el profesor jefe debe comunicarse de forma particular a un alumno


> 3 niveles de comunicacion
>> entregar informacion a nivel del establecimiento (por el profesor jefe)
> 
>> entregar informacion a nivel de curso
> 
>> entregar informacion a nivel de profesor a alumno en particular

> Escenario 3: reunion de apoderados
>> el profesor jefe debe entregar a cada apoderado las notas del alumno 
> 
>> el profesor jefe comunica a los apoderados informaciones relevantes (a nivel establecimiento y de curso)
> 
>> profesor jefe se comunica con un apoderado en particular sobre alguna situacion

> la idea es que la comunicacion sea unidimensional
> el profesor le manda un aviso al alumno, este aviso la idea es que sea copiada y enviada al apoderado

> Escenario 4: escenario actual
>> se debe informar sobre posible caso estrecho
>
>> suspension de emergencia de actividades presenciales
>
>> alumnos y apoderados deben estar al tanto de las comunicaciones

> como la comunicacion es unidimensional, debe haber algun apartado que muestre los correo o datos del profesor para que exista aunque sea externo una comunciacion entre alumno y profesor.

> Actores que interactuan en la plataforma segun su nivel
> 
> Director
>> Jefe de UTP
>>> Profesor jefe
>>>> Profesor asignatura
>>>>> Apoderados
>>>>>> Alumnos

> contacto estrecho debe ser informado al curso, no a todo el colegio

> Que se necesita:
>
> los alumnos/apoderados deben tener horario de clases a las cuales deben asistir
> 
> planificacion de las actividades importantes 
> 
> miembros de la comunidad deben tener informacion basica disponible y acceso a la particular
> 
> comunicacion relevante entre actores

> ingresar con credenciales


## Lecturas

#### Primera Lectura

> Unusable Software Is Useless | el software inutilizado es inutil

software person = persona de software = programador o arquitecto de software

LA USABILIDAD TIENE UN IMPACTO SIGNIFICATIVO
sobre el éxito de los sistemas y productos centrados en software.
Por ejemplo, si un sistema de software no es compatible con los usuarios finales en su trabajo diario, no se utilizará
productivamente. 

Del mismo modo, si los desarrolladores no entienden la arquitectura de su software,
la variacion de la complejidad y arquitectura del codigo seran consecuencias obvias.

En última instancia, no diseñar software utilizable
podría degradar seriamente la capacidad de un proyecto de entregarse a tiempo, presupuesto, funcionalidad y calidad.

En las dos próximas entregas de este
columna, exploro seleccionados pero esenciales
actividades, métodos y técnicas que sirven de apoyo a los arquitectos pragmáticos en el desarrollo de sistemas para su uso. Esta entrega en particular se centra en la usabilidad operativa; Me centro en dos aspectos que contribuyen significativamente a diseñar sistemas aceptados por clientes y usuarios finales: idoneidad empresarial y ergonomía.

>> Business Suitability | idoneidad(aptitud) empresarial

Cada sistema de software está construido para un propósito específico y negocio, todos lo sabemos.
Por lo tanto, el interés principal de los clientes es que el sistema de software que compran sirvan bien para sus negocios. 
Sin embargo, una y otra vez, he observado proyectos de software que **tienden a mantener el diálogo con los clientes en un "Mínimo inevitable"**,
como si fuera necesario pero no particularmente una actividad útil.
A pesar de todas las prácticas ágiles que recomiendan involucrarlos temprano a los clientes y, con regularidad, **"los clientes no saben lo que realmente quieren o necesitan”** es una frase que escucho a menudo.
La misma observación también se aplica a los productos de software, en que los principales "clientes" se encargan casi siempre de la gestión de productos de la empresa,
divisiones de marketing y ventas en vez de probar si es un buen producto para el usuario final (se encargan solo del marketing y no tanto de probar el producto).

Sin embargo, los proyectos de software que no están en continuo diálogo con las partes interesadas del negocio pierden una gran oportunidad
para ganar y que estas partes interesadas confien y se aseguren de sus sistemas de trabajo. 
Este diálogo puede ser un desafío para personas con fuerte antecedentes técnicos porque el interés empresarial de 
los titulares normalmente no hablan en términos de requisitos concretos o arquitectura de conceptos, 
solo hablan de las cosas en las que los arquitectos estan interesados.
Y si lo hacen, ellos tienden a expresar sus requisitos más como deseos o en términos vagos y ambiguos.

Sin embargo, los actores económicos (business stakeholders) estan generalmente interesadas en conocer 
el software o sistemas que patrocinan y ser involucrado en decisiones clave.
Para iniciar diálogo con las partes interesadas del negocio (business stakeholders), 
Los arquitectos pueden elegir entre un conjunto completo de métodos. 
La clave del éxito aquí es (en mi experiencia), que el propósito previsto del software sea el enfoque principal.
Comprender y capturar de manera concreta el dominio de un modelo suele ser un buen
comienzo para obtener la perspectiva general del cliente en un sistema.
Esto a menudo significa menos en términos de requisitos concretos pero más en términos de la estructura
de este sudominio y, lo que es más importante, que el núcleo de trabajo fluya, tareas y actividades que para transpirar y desarrollar asi
ese dominio. Trabajar en el modelo del dominio también indica a los clientes que los arquitectos hablan en el "correcto"
idioma y pueden entender sus intereses.

En todos los proyectos en los que me he envuelto en mi carrera, los consumidores o clientes han confirmado 
que elaborar un modelo de dominio fue un resultado valioso para ellos mismos, incluso desde, una perspectiva tecnica,
eso era "solo" un vehículo para impulsar el diseño y implementación de una manera correcta.

Los modelos de dominio también son vehículos adecuados para obtener y aclarar requisitos clave junto con especificaciones de escenarios concretos.
Los escenarios ayudan a especificar los estímulos relevantes y las respuestas esperadas para todas las tareas relevantes del sistema.
ellos consideran el sistema en sí ser una **black box**.
La asignación de escenarios al modelo de dominio amplía esta vista a cómo el sistema realizará tareas relevantes como flujos de trabajo concretos en el dominio de la aplicación, incluidos los requisitos de calidad relevantes, como el rendimiento y las variaciones de escenario.
Utilizando el modelo de dominio y los escenarios como guía, la especificación y clasificación del alcance y los requisitos de un sistema se basa, por lo tanto, en menos suposiciones y más en las necesidades reales y el valor comercial.

Otros métodos ayudan en la comunicacion de la arquitectura del sistema,
las consecuencias y las compensaciones, junto con los comentarios recibidos sobre si cumple las expectativas del cliente
Este tipo de esqueleto ayuda al arquitecto a realizar escenarios funcionales clave al ilustrar cómo funciona la arquitectura a través de la experiencia del sistema real en lugar de descripciones formales del diseño.
Las notaciones de modelado de software y sistemas son útiles y esenciales para la documentación y comunicación técnica adecuadas de una arquitectura, pero es probable que requieran una explicación significativa para que las partes interesadas del negocio las comprendan.
La experiencia real del sistema también es esencial para obtener comentarios útiles sobre la idoneidad de la arquitectura; Las partes interesadas del negocio a menudo no pueden discutir las consecuencias de las decisiones de diseño basadas en diagramas o descripciones textuales.

Cuando es necesario explicar las arquitecturas a través de diagramas técnicos, 
las metáforas son un vehículo útil porque ayudan a esbozar el diseño concreto de un sistema
al describirlo en términos de como es su estructura pero aplicado en un contexto sobre algo del mundo real. Por ejemplo, suelo utilizar la metáfora de "herramientas y materiales" para describir la estructura clave de los editores gráficos.
los objetos que manipula el sistema corresponden a los materiales y la funcionalidad de edición a las herramientas. El concepto de "carrito de compras" es otra metáfora bien conocida que se usa comúnmente para describir la funcionalidad de compra en los sistemas de comercio electrónico.

>> Ergonomics | Ergonomía

Los usuarios finales viven con los sistemas que construimos, por lo que su principal interés es que estos sistemas respalden su trabajo diario de manera efectiva.
De lo contrario, es probable que no acepten nuestros sistemas porque los hacen menos productivos.
En dominios críticos para la seguridad, como la automatización ferroviaria,
la capacidad de usar un sistema de manera efectiva y correcta en todas las circunstancias
relevantes es realmente obligatoria para obtener la certificación necesaria.

Desafortunadamente, parece existir un conflicto entre
la visión técnica de muchos programadores de software
y la visión orientada a tareas de muchos usuarios finales. Un ejemplo del mundo real que encontré recientemente en uno de mis proyectos fue una herramienta de ingeniería para un producto de automatización industrial.
Esta herramienta expuso la vista física completa del producto, que constaba de aproximadamente 10,000 parámetros, al usuario final, sin embargo, la mayoría de los usuarios no estaban interesados en configurar parámetros individuales de la máquina porque es una actividad tediosa y propensa a errores.
En cambio, su principal interés estaba en diseñar tareas completas que fueran significativas en su dominio de aplicación, como encender una máquina específica o mover la máquina a una posición de mantenimiento.

Claramente, una forma eficaz de comprender las necesidades y los requisitos del usuario final es involucrar a los usuarios de forma activa en el diseño del sistema, con un enfoque en la interacción persona-computadora.

HCI se centra específicamente en los usuarios de un sistema
y las tareas que realizan: ¿Qué características debería ofrecer el sistema para realizar tareas específicas del usuario? ¿Qué pasos son necesarios para realizar esas tareas de manera eficiente? ¿Cómo debería ofrecer sus funciones la interfaz de usuario del sistema?
En mi experiencia, es en realidad esta orientación de tareas la que permite a los usuarios trabajar con un sistema de manera productiva porque admite una operación del sistema intuitiva e integrada. No se logra a través de una apariencia elegante de la interfaz de usuario, como podrían asumir algunos programadores de software. Un aspecto nuevo y atractivo suele ser más importante para fines de marketing, para indicar que un sistema está actualizado y sigue la última tecnología.

Métodos como el diseño participativo o el diseño centrado en el uso, junto con patrones y prácticas documentados para HCI, permiten el diseño cooperativo de interfaces de usuario orientadas a tareas y diseños de flujo de trabajo. Estos métodos definen actividades concretas para la cooperación entre usuarios y desarrolladores y los resultados y artefactos esperados.
Muchos de los proyectos en los que estoy involucrado actualmente llevan a cabo talleres de usabilidad regulares con clientes y usuarios finales.
Los patrones y prácticas de HCI definen un lenguaje común entendido por todas las partes: los usuarios finales pueden expresar lo que necesitan, y los arquitectos y desarrolladores obtienen información sobre qué construir y cómo.

Por ejemplo, los patrones de Jan Borchers para hardware invisible y dispositivos apropiados para el dominio enfatizan la importancia de ocultar tecnologías de hardware complejas y desconocidas a los usuarios del sistema.
permitiéndoles en cambio comunicarse con el sistema utilizando dispositivos y abstracciones que conocen de sus propios dominios. Otros patrones, como el árbol plano y estrecho y la información justo a tiempo, logran el equilibrio estrecho entre no abrumar a los usuarios con demasiada información y proporcionar datos insuficientes.

De manera similar a la discusión anterior sobre la idoneidad empresarial, la participación de los usuarios finales en el diseño de HCI de un sistema guía el trabajo de arquitectura concreta de un proyecto de software. Los estudios de usabilidad con prototipos de interfaz o, mejor aún, esqueletos ambulantes, brindan información sobre la usabilidad real de ese diseño, con una oportunidad adicional para mejoras y ajustes. El ciclo de retroalimentación de la participación activa del usuario se cierra, pero de una manera que brinda a los arquitectos la mejor orientación para diseñar sistemas con los que los usuarios finales puedan "vivir bien".

Los desarrolladores son el tercer grupo importante de usuarios de sistemas centrados en software: viven dentro de la arquitectura y el código de un sistema.
Por lo tanto, es una responsabilidad clave de los arquitectos asegurarse de que los desarrolladores se sientan habitables allí. La próxima entrega de esta columna explorará los métodos y las mejores prácticas que ayudan a los arquitectos a lograr esta tarea.

**Resumen**

> Business Suitability
>> los proyectos de software que no están en continuo diálogo con las partes interesadas del negocio pierden una gran oportunidad para ganar y que estas partes interesadas confien y se aseguren de sus sistemas de trabajo.
> 
>>  los actores económicos (business stakeholders) estan generalmente interesadas en conocer el software o sistemas que patrocinan y ser involucrado en decisiones clave.
> 
>> el propósito previsto del software sea el enfoque principal. Comprender y capturar de manera concreta el dominio de un modelo suele ser un buen comienzo para obtener la perspectiva general del cliente en un sistema
> 
>> los consumidores o clientes han confirmado que elaborar un modelo de dominio fue un resultado valioso para ellos mismos
> 
>> modelos de dominio también son vehículos adecuados para obtener y aclarar requisitos clave junto con especificaciones de escenarios concretos
> 
>> Utilizando el modelo de dominio y los escenarios como guía, la especificación y clasificación del alcance y los requisitos de un sistema se basa, por lo tanto, en menos suposiciones y más en las necesidades reales y el valor comercial.
> 
>> Cuando es necesario explicar las arquitecturas a través de diagramas técnicos, las metáforas son un vehículo útil porque ayudan a esbozar el diseño concreto de un sistema al describirlo en términos de como es su estructura pero aplicado en un contexto sobre algo del mundo real
> 

> Ergonomics
>> Los usuarios finales viven con los sistemas que construimos, por lo que su principal interés es que estos sistemas respalden su trabajo diario de manera efectiva
> 
>>  la mayoría de los usuarios no estaban interesados en configurar parámetros individuales de la máquina porque es una actividad tediosa y propensa a errores
> 
>> una forma eficaz de comprender las necesidades y los requisitos del usuario final es involucrar a los usuarios de forma activa en el diseño del sistema, con un enfoque en la interacción persona-computadora
> 
>> HCI se centra específicamente en los usuarios de un sistema y las tareas que realizan
> 
>>  los patrones de Jan Borchers para hardware invisible y dispositivos apropiados para el dominio enfatizan la importancia de ocultar tecnologías de hardware complejas y desconocidas a los usuarios del sistema
>>>  permitiéndoles en cambio comunicarse con el sistema utilizando dispositivos y abstracciones que conocen de sus propios dominios
> 
>> La Interacción Persona-Ordenador del inglés Human Computer Interaction (HCI) «es una disciplina relacionada con el diseño, evaluación, desarrollo y estudio de los fenómenos que rodean los sistemas informáticos para uso humano»

#### Segunda Lectura:

**TEXTO DE IAN ALEXANDER**

la clave del éxito de los sistemas es construir lo que los interesados desean. En cierto modo, no se puede negar este punto: nadie quiere construir lo que las partes interesadas no desean. Pero, como siempre, el diablo está en los detalles.
Voy a contrastar dos ejemplos para ilustrar lo que puede significar construir lo que los interesados desean:

> El proyecto A es un juego de rol en un dispositivo portátil para el mercado adolescente.
>
> El proyecto B es un sistema de software integrado para controlar las operaciones de una línea ferroviaria.

El director de producto del proyecto A no duda de que la clave del éxito es construir lo que sus consumidores adolescentes quieren: emoción, velocidad, sensación de dominio, etc. Estas experiencias emocionales están muy alejadas de los requisitos tradicionales, como argumentó recientemente David Callele ("Emotional Requirements in Video Games", Proc. 14th IEEE Int'l Requirements Eng. Conf., IEEE CS Press, pp. 299-302). Y más allá de ellos, lo que los jugadores quieren es difícil de precisar porque el mercado cambia rápidamente y en cualquier momento un competidor (una poderosa parte interesada negativa) puede producir un juego que transforme las expectativas de todos los productos futuros.
Otras partes interesadas son los reguladores, que deciden en nombre del público, por ejemplo, si el juego es excesivamente violento o sexual. Estas partes interesadas son importantes, e incluso pueden ser llamativas.
El regulador, a su vez, está influenciado por los políticos, que responden al estado de ánimo del público.
Está claro que es esencial equilibrar los deseos de los reguladores con los de los jugadores, pero también lo es derrotar a la competencia: construir lo que los interesados negativos no desean. Por último, el proyecto A es un éxito comercial si gana dinero, es decir, si satisface a sus beneficiarios financieros, como los directores y accionistas de la empresa.
El modelo de cebolla de la figura 1 ilustra las presiones de las partes interesadas que compiten entre sí y que el director de producto debe mediar en el proyecto A.
El proyecto B es diferente. Su director de proyecto y su ingeniero jefe saben que la clave del éxito es construir una vía férrea que funcione de forma segura. La aprobación del regulador de seguridad es obligatoria, pero antes el proyecto debe integrar todos los componentes de los subcontratistas para hacer un sistema que realmente funcione. Por eso, las interfaces especificadas en la arquitectura del sistema son cruciales. En teoría, el equipo del sistema puede elaborar las interfaces de antemano e imponer requisitos a los subcontratistas para que, por ejemplo, la salida de un sistema de señalización sea exactamente titular, y el proyecto sólo puede avanzar mediante la negociación. Preferiblemente, no se pisotean los deseos de las partes interesadas menos poderosas. El modelo de la cebolla para este caso tendría un aspecto muy diferente al de la figura 1.
Espero que estos ejemplos muestren que frases como "lo que desean los interesados" ocultan una multitud de peligros.
Para hacer frente a esos deseos hay que hacer concesiones entre grandes fuerzas opuestas que varían mucho de un proyecto a otro. El primer paso es averiguar quiénes son las partes interesadas, entre las que se encuentran no sólo los beneficiarios, sino también las partes interesadas negativas, cuyos deseos no deben satisfacerse.
Entonces, ¿hay que dar a los interesados lo que desean? Es imposible complacer a todo el mundo, por supuesto, pero la satisfacción general de los deseos de los principales interesados es crucial para el éxito del producto

**TEXTO DE Kent Beck**

Hay un viejo dicho en el desarrollo de software que dice que los usuarios no saben lo que quieren hasta que se les da lo que piden. Los desarrolladores experimentados suelen sonreír con pesar cuando oyen esto, ya que al menos una vez en su carrera les han dicho que un sistema que habían entregado era totalmente inaceptable cuando era exactamente (por lo que podían decir) lo que se pedía. No sólo hay que cumplir las órdenes para ofrecer un buen software. Aquí describo el papel positivo que pueden desempeñar los desarrolladores a la hora de descubrir y explorar los requisitos.
Es una exageración decir que lo peor que se puede hacer es entregar exactamente lo que los usuarios te dicen. Hacer promesas y no entregar nada es peor. Entregar lo que quieres desarrollar sin tener en cuenta lo que quieren es peor. Pero poner la mayor parte de ti mismo en el estante mientras desarrollas está ciertamente lejos de la mejor manera de entregar un software satisfactorio. Una crítica superficial a DWTTY (Do What They Tell You) es que conduce a muchas peticiones de cambio. En realidad, esto es un punto fuerte de escuchar y responder a lo que los clientes te dicen. Las solicitudes de cambio son una señal de que los clientes están comprometidos, se preocupan y piensan. Hagan lo que hagan los desarrolladores más allá de DWTTY, no deberían perder esta sensación de que los clientes quieren seguir mejorando el sistema.
¿Qué sucede cuando los desarrolladores DWTTY? En primer lugar, las funciones solicitadas suelen ser más caras de lo necesario.
Por lo general, hay varias formas de implementar una función determinada. Al discutir una función con los clientes, los desarrolladores pueden ofrecer opciones con sus costes asociados. En segundo lugar, las funciones solicitadas pueden carecer de coherencia. Los desarrolladores tienen la ventaja única de poder ver todo un dominio con ojos nuevos. A veces pueden descubrir aspectos comunes ocultos entre operaciones aparentemente diversas y así simplificar drásticamente la interfaz. En tercer lugar, los clientes suelen tener una comprensión monolítica del sistema que imaginan, lo que conduce a un desarrollo más arriesgado. A menudo es necesario que los desarrolladores vean cómo dividir el sistema en versiones incrementales, cada una de las cuales aporta valor. Por lo tanto, DWTTY da lugar a sistemas más caros y menos coherentes que se entregan en grandes y arriesgadas versiones. Aparte de estos problemas técnicos, DWTTY adolece del defecto fatal de la falta de responsabilidad. "Oye, no te quejes conmigo. Sólo hice lo que me dijeron" no es una posición responsable. El desarrollo de software funciona mejor cuando todos los implicados aceptan la responsabilidad del valor del sistema. Los desarrolladores responsables aplican su creatividad y esfuerzo de forma más completa y evitan los atajos que restan valor a los sistemas.
Hay muchas alternativas a DWTTY. Un desarrollador de pensamiento binario diría: "Bueno, si ellos no están a cargo, entonces yo estoy a cargo". Esta estrategia niega a los clientes su derecho a ser responsables del sistema. El desarrollador, con un conocimiento necesariamente superficial del dominio, probablemente tomará muchas decisiones erróneas, especialmente en las primeras etapas críticas del desarrollo.
La pregunta no es: "¿Quién manda?", sino: "¿Cómo podemos trabajar juntos?".
La segunda edición de Extreme Programming Explained enumera 14 principios coherentes con la excelencia en el desarrollo. Todos ellos se aplican al diálogo sobre los requisitos. Podría repasar los 14 principios, pero sólo dispongo de 750 palabras y estoy deseando ver lo que tiene que decir mi digno oponente, así que mencionaré uno y dejaré que exploren el resto. El principio de los pasos de bebé sugiere trabajar en pasos pequeños y concretos. Si aplicamos este principio a los requisitos, el diálogo de requisitos animará a todos a conseguir algo concreto de forma rápida y frecuente. Los pasos de bebé crean retroalimentación, reducen el esfuerzo desperdiciado y fomentan la confianza entre los miembros del equipo.
En general, un equipo puede manifestar estos principios de muchas maneras. Un equipo al estilo de ExtremeProgramming podría sentarse juntos, emparejar a un cliente y a un desarrollador
para las tareas difíciles, o lanzar el software a la producción semanalmente. Un equipo de estilo cascada podría utilizar los mismos principios para celebrar sesiones de diseño conjuntas, formar a los desarrolladores como usuarios del sistema que se va a sustituir o dividir el ciclo de lanzamiento a la mitad (dos lanzamientos al año fomentarán más la colaboración que uno).
Las prácticas precisas no son tan importantes como la intención que hay detrás de ellas. Si todos los miembros del equipo aceptan la responsabilidad del valor del sistema, si los desarrolladores se comprometen a escuchar las necesidades reales de los clientes, si los clientes asimilan los comentarios sobre sus deseos, todo el equipo logrará mucho más de lo que lograría si los desarrolladores se limitaran a "hacer lo que me dicen".


## Ayudantias

#### Jira: gestionar historias de usuarios atravez de una pizarra kanban

> ![](/TheusZero/images/post/ads/51.png)
> ![](/TheusZero/images/post/ads/52.png)

