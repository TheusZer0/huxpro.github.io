---
layout: post
title: "POO para C++"
subtitle: 'POO para C++'
date: 2021-07-21 12:00:00
author: "TheusZero"
header-img: "images/post/PythonAutoayuda/solarized-wallpaper-python.png"
catalog: true
comments: true
tags:
    - Programacion
    - Python
    - USM
    - Tareas
    - Java
    - C++
---

![](/TheusZero/images/post/POO/63.png)

## Programacion en C++ Links

[]()

[]()

## Introducción a C++

diapositiva 1:

#### C++ vs C


> C++ es un lenguaje posterior a C

> C++ mantiene todo el poder de C agregando características que
facilitan la programación. C++ es compatible hacia atrás con C.

> C++ permite la programación orientada a objetos y, como las
últimas versiones de Java, permite programación genérica. A
diferencia de Java, C++ permite  crear programas en el paradigma
procedural u orientado a objetos según se necesite. ¡Incluso
mezclas entre ellos!

> C++ posee una biblioteca de funciones más amplia que C. Las
bibliotecas ya existentes de C son en su mayoría compatibles con C++

#### C++ vs Java

C++ es plataforma dependiente (Bibliotecas como Qt buscan resolver este
problema).

> C++ soporta herencia múltiple.

> C++ soporta sobrecarga de operadores (Ej: es posible dar nuevas funcionalidades
> al operador “+”).

> Mientras Java utiliza punteros, C++ soporta el uso de éstos y operaciones sobre los
> mismos de forma explícita.

> C++ soporta tanto llamadas (o paso de parámetros) por valor como por referencia,
> mientras Java solo soporta llamadas por valor

> No existe un equivalente nativo para documentación en C++ como lo hay en Java
> (Javadoc). Se puede usar Doxygen.

> C++ crea nuevos árboles de herencia en cada programa. Java tiene un solo árbol
de herencia, pues todo hereda de la clase Object.


#### Proceso de compilación en C++

> Involucra tres pasos:
>
> Preprocesamiento: El pre-procesador toma el archivo del código fuente y procesa todas las directivas
que comienzan con # (#include, #define, etc). La salida es un archivo C++ puro.
> 
> Compilación: el compilador toma la salida del pre-procesador y genera un archivo objeto (primero
assembler y luego binario de extensión .o) por cada archivo de código fuente ejecutable.
> 
> Ligado (linking): toma los archivos generados por el compilador y produce un archivo ejecutable (o
una biblioteca -no en este curso-)

![](/TheusZero/images/post/POO_C++/1.png)

#### Archivos de encabezado

ELO329 Diseño y Programación Orientados a Objetos 5
Archivos de encabezadoSon necesarios para declarar prototipos y definir constantes usadas en el programa.

Son incluidos con la directiva del pre-procesador

```#include```

Ejemplo:

```vim
#include <vector>
#include <sys/socket.h>
#include “setup.h”
```

Al usar <....> la búsqueda del archivo se hace en lugares “estándares” definidos por el
compilador.

Los directorios estándares varían en cada instalación. Para ver cuáles son en tu
sistema, puedes usar:

```vim
$ touch a.c  // o el comando para crear un archivo a.c vacío.$ gcc -v -E a.cMostrará los directorios a buscar para archivos 

#include <...>    e
#include “...”

```

#### Tipos de variables

```vim
int
short int ( o short)
long int (o long)
unsigned int (o unsigned)
unsigned long int (o unsigned long)
unsigned short int (unsigned short)
char 
float
double
long double
bool
```

#### Acceso de Variable

**Las variables en C++ como en C, representan a los valores en sí y no
referencias a éstos**. En Java esto es así sólo para los tipos simples escalares
como int, float, double, char y boolean.

La diferencia entre C++ y Java se hace notar al manejar objetos

Objetos en Java son referencias a éstos y todos se encuentran en el heap.
Mientras que en C++ los nombres de objetos siempre se refieren al objeto mismo
y se pueden encontrar en el heap, en stack o en segmentos de datos de la
memoria.

> ```vim
> //Ej: en C++
> 
> Empleado juan, pedro; // al momento de crear la variable ya se
>  // crea el objeto invocando el constructor. Distinto de Java
>  
> juan=pedro; // hace que juan tome todos los atributos de pedro.
> ```
> 
> Un cambio posterior a juan no afecta a pedro.
>
> Ésta es una gran diferencia con la semántica en Java

#### Salida de Datos

iostream debe ser incluido para hacer uso de las operaciones de entrada y
salida.

```vim
#include <iostream>
using namespace std; // para usar el objeto cout
int main (void){
 cout << “Hello, world” << endl;
 return 0;
}
```

Es posible enviar datos a la salida estándar o a archivos:

```vim
#include <fstream>
ofstream os (“output.dat”);
os << “The value of pi is approx. “ << 3.14159 << endl;
```

```vim
#include <iostream>
#include <fstream>
using namespace std;
int main() {
int i;
ifstream fin;
fin.open("test"); // test contains 3 ints
for (int j=0;j<3;j++) {
fin >> i;
cout << i << endl;
}
fin.close();
}
```

#### Lectura desde archivo: Ejemplo

```vim
#include <string>
#include <fstream>
#include <iostream>
using namespace std;
int main() {
 string s;
 ifstream fin;
 fin.open("/etc/passwd");
 while(getline(fin,s))
 cout << s << endl;
}
```

#### Operadores aritméticos

![](/TheusZero/images/post/POO_C++/2.png)

#### Asignaciones, Arreglos y Vectores

Todas asignación tiene un valor, aquel asignado. Ej: a=b=c;

ANSI C++ usa el mismo constructor de arreglo que C

Como los arreglos de C no son particularmente poderosos,
C++ incorpora vectores (no corresponde al concepto de vector
geométrico). Éstos son análogos a los ArrayList de Java.

Los vectores son una forma de plantilla (template). Una plantilla es una
declaración de clase con un tipo de dato como parámetro, su uso es
simple:
vector <X> a(n); // Ojo aún no usamos new como en Java...
crea un arreglo “crecedor” de elementos de tipo X con espacio para n
elementos.

El acceso es con: a[i]

#### Vectores

Pueden crecer según nuestra necesidad ```vector <double> a;```

En este caso a está vacío. Para hacerlo crecer:

```vim
a.push_back(0.3);
a.push_back(56.2);
```

También podemos hacer que el vector crezca en varios elementos: ```a.resize(10);```

Podemos preguntar por el tamaño de un vector con a.size(); como en:

```vim
for (int i=0; i < a.size(); i++)
 // ..... por más detalles ver www.cplusplus.com
```

#### Strings

En ANSI C++ tenemos acceso a una clase poderosa para string.

Ésta tiene definido el operador copia =, el operador concatenación +
y operadores relacionales ==, !=, <, <=, >, >=, entre otros.

El operador [ ] provee acceso a elementos individuales.

Existen muchos métodos en esta clase como substr para extraer un
substring:

```vim
string s = “Hola a todos”;
int n = s.length(); // asigna 12
char ch = s[0];
string t = s.substr(0,4); // Substring de s[0] a s[4]
```

#### Control de Flujo

Se dispone de las opciones comunes en otros lenguajes:

```vim
if (condición)
    block1 // Un bloque de instrucciones se delimita con { }
else
    block2
    La parte else es opcional.

while (condición) block 
do
    block
while (condición);

for(expresión; expresión2; expresión3)
    instrucción_a_repetir 

switch : análogo a Java
```

#### Punteros (resumen)

Toda variable tiene un cierto valor o estado y una dirección de
memoria asociada.

![](/TheusZero/images/post/POO_C++/3.png)

Las variables punteros, tienen almacenada la dirección en memoria
de otra variable o dato.

Definición en C/C++: Para definir una variable como puntero, se
utiliza el operador “*”

```vim
 int *pVar; // pVar almacena una dirección de memoria para alojar un entero
```

A una variable de tipo puntero, almacena la dirección de memoria
de otra variable. Para obtener la dirección de una variable en C/C++
se utiliza el operador “&”

![](/TheusZero/images/post/POO_C++/4.png)

Es posible obtener el valor de la variable a la cual se apunta
utilizando el operador “*”:

> ```cout << &pVar <<endl; // Imprime la dirección de pVar (3571)```
> 
> ```cout << pVar << endl; // Imprime el contenido de pVar (1776)```
> 
> ```cout<< *pVar <<endl; // Imprime el valor del contenido apuntado (5)```


>> Operadores:
>
> Operador de dereferencia (*): Permite acceder al valor de aquella variable a la
> que se apunta
>
> Operador de referencia (&): Permite obtener la dirección de memoria de la
> variable solicitada

#### Paso por referencia

En C++ tenemos un nuevo tipo de paso de argumentos, el paso por referencia.

El efecto es equivalente al uso de punteros en C. La sintaxis cambia.

En C se puede hacer:

> ```vim
> void swap_en_C(int * px, int * py){
>     int tmp = *px;
>     *px = *py;
>     *py=tmp;
> }
> ```
> El llamado es swap_en_C(&a, &b)

> Ahora en C++, tenemos la opción anterior y una más simple:
> ```vim
> void swap_en_Cplusplus (int & x, int & y){
>     int tmp = x;
>     x=y;
>     y=tmp;
> }
> ```
> El llamado es swap_en_Cplusplus(a,b);

> Obviamente:
>> ```swap_enCplusplus(4,x);``` // no es legal
>> ```swap_enCplusplus(i+2,j-1);``` // no es lega

![](/TheusZero/images/post/POO_C++/5.png)


## Clases y objetos en C++

El concepto de clase y objeto ya visto para Java no cambia en C++. Estos
conceptos son independientes del lenguaje

Lenguaje: en los textos de C++ es común referirse a los atributos como los
**miembros dato** de la clase y a los métodos como **miembros función**

Mientras en Java todos los objetos son creados y almacenados en el Heap
(o zona de memoria dinámica), en C++ los objetos se pueden ubicar en
stack (zona de memoria dedicada al proceso y determinada durante
compilación) o en memoria dinámica (solicitada durante ejecución).

Al definir un objeto estáticamente en C++, su creación queda determinada.
En cambio, en java se define el nombre y el objeto se crea usando new.

Para crear objetos en el heap, en C++, se usa punteros a objetos y, como
en Java, se crean con new. En este caso cambia la notación pero na
semántica es similar a la de Java.

#### Ubicación de Objetos en C++ (para ir notando diferencia)

![](/TheusZero/images/post/POO_C++/6.png)

#### Estructura Básica de programas C++

En C++ es recomendado separar en distintos archivos la definición de una
clase por un lado y la implementación de ésta en otro archivo.

Se crea un archivo de encabezado “clase.h”, en él podemos la **definición
de la clase**, es decir los atributos y prototipos de métodos.

En otro archivo “clase.cpp” ponemos la **implementación** de cada
método. En este archivo debemos incluir el archivo de encabezado
“clase.h”

Podemos implementar varias clases por archivo y un .h puede tener la
definición de varias clases, pero se recomienda hacer un .h y un .cpp por
cada clase.

#### Estructura de archivos

![](/TheusZero/images/post/POO_C++/7.png)

![](/TheusZero/images/post/POO_C++/8.png)

#### Calificadores de Acceso Público y Privado: es similar a Java

> Los miembros precedidos por el calificador public son visibles fuera de la clase
>> por ejemplo, un miembro público es visible desde el main(), como es el caso de cin.get(), cin es el objeto, get es la función de acceso público.
>
>> Es el calificador por omisión en estructuras (uso de struct en lugar de class).

Los miembros precedidos por el calificador **private** quedan ocultos para
funciones o métodos fuera de la clase. **Calificador por omisión en clases**.

Miembros precedidos por **protected** pueden ser accedidos por miembros de la
misma clase y clases derivadas.

Las clases y funciones amigas (más adelante) tienen acceso a todo.

![](/TheusZero/images/post/POO_C++/9.png)

#### Ejemplo: Clase Automóvil

> Imaginemos que queremos modelar un automóvil:
>> Atributos: marca, número de puertas, número de cilindros, tamaño del motor
>
>> Operaciones: fijar y obtener número de puertas, entrada y despliegue de atributos, partir, parar, revisar_gas

![](/TheusZero/images/post/POO_C++/10.png)

#### Clasificación de Funciones Miembros en una Clase

Un **“accesor”** es un método que retorna un valor desde su objeto, pero
no cambia el objeto (sus atributos). Permite acceder a los atributos del
objeto.

Un **mutador** es un método que modifica su objeto

Un **constructor** es un método con el mismo nombre de la clase que se
ejecuta tan pronto como una instancia de la clase es creada.

Un **destructor** es un método el mismo nombre de la clase y una
virgulilla () antepuesta. Ej.: Automobil()

> ejemplo Clase automovil

![](/TheusZero/images/post/POO_C++/11.png)

#### Creando y accediendo un Objeto

![](/TheusZero/images/post/POO_C++/12.png)

#### Constructores: Similar a Java

Un constructor se ejecuta cuando el objeto es creado, es decir, tan pronto
es definido en el programa. Ej. Esto es antes de la función main() en el
caso de objetos globales y cuando una función o método es llamado en el
caso de datos locales.

En ausencia de constructores, C++ define un construcción por omisión, el
cual no tiene parámetros.

Debemos crear nuestro constructor por defecto si tenemos otros
constructores.

Si definimos un arreglo de objetos, el constructor por defecto es llamado
para cada objeto:

```vim
Point drawing[50];  // calls default constructor 50 times
                    // a diferencia de Java aquí ya tenemos 50 Puntos.
```

#### Implementación de Constructores

Podemos implementar un método en la definición de la clase. Se conoce
como código “inline”

Un constructor por defecto para la clase Point podría inicializar X e Y:

```vim
class Point {
public:
    Point() { // función inline , usarla solo si
    m_X = 0; // implementación es simple.
    m_Y = 0;
 } // Ojo no va ; aquí, es el fin del método.
private:
 int m_X;
 int m_Y;
};
```

#### Funciones Out-of-Line

Todos los métodos deben ser declarados (el prototipo) dentro de la
definición de una clase.

La implementación de funciones no triviales son usualmente definidas fuera
de la clase y en un archivo separado, en lugar de ponerlas in-line en la
definición de la clase.

> Por ejemplo para el constructor Point, la implementación “of-line” sería:
> ```vim
> Point::Point() {
>  m_X = 0;
>  m_Y = 0;
> }
> ```

El símbolo **::** permite al compilador saber que estamos definiendo la función
Point de la clase Point. Este también es conocido como operador de
**resolución de alcance ::**

> Clase Automobile (revisión)
> ![](/TheusZero/images/post/POO_C++/13.png)

> Implementaciones de los métodos de Automobile
> ![](/TheusZero/images/post/POO_C++/14.png)

> Implementación del método de entrada
> ![](/TheusZero/images/post/POO_C++/15.png)

#### Constructores

Como en Java, múltiples constructores pueden existir con
diferentes listas de parámetros:

> 1/5: Sobrecarga
> ![](/TheusZero/images/post/POO_C++/16.png)
>
> 2/5: Invocación
> ![](/TheusZero/images/post/POO_C++/17.png)
>
> (3/5): Implementación
> ![](/TheusZero/images/post/POO_C++/18.png)
>
> (4/5): visibilidad de Parámetros
> ![](/TheusZero/images/post/POO_C++/19.png)

> (5/5): Lista de Inicialización
> ![](/TheusZero/images/post/POO_C++/20.png)

#### Destructores

Una diferencia importante con Java es la presencia de destructores. Lo
más cercano en java es el método finalize() (hoy obsoleto) de la clase
Object.

Java tiene un proceso de “recolección de basura” por lo que hace los
destructores no críticos.

En C++ el **destructor se invoca en forma automática** justo antes que el
objeto sea inaccesible para el programa.

El método destructor no tiene parámetros, se llama igual a la clase y lleva
un signo ~ como prefijo.
```Ej: Automobile::~Automobile() {}``` 

## const, referencias (&), y macro assert en C++ 

modificadores que se pueden aplicar al codigo

#### const

es como el final de Java

> Tiene varios usos:
>> Para evitar que una atributo, variable o parámetro cambie. Es mejor que
> #define
>> Para indicar que un método no cambia el estado de un objeto.
>
>> El objeto calificado como constante debe tener un valor asignado en su definición o vía lista de inicialización.

```vim
const int n = 25;
n = 36; // error
const double z; // error
int m = n;
m = 36; 
```

#### Calificador const en punteros

> Hay dos posiciones con distinto resultado.
>> int * const a; // no puedo cambiar a
> 
>> const int *a; // no puedo cambiar el contenido apuntado

```vim
    void MySub( const int *a ) { // Contenido constante!
    *a = 50; // error
    a++; // ok
    }
```

En este ejemplo, el puntero sí puede ser modificado, pero esto no
tiene efecto duradero o posterior ya que el puntero es pasado por
valor (se crea uno local y se copia el valor el parámetro actual).

![](/TheusZero/images/post/POO_C++/21.png)

#### Punteros Constantes

La declaración de un **puntero constante** solo garantiza que el
puntero en sí no pueda ser modificado

```vim
void MySub( int * const a ) { // Puntero constante
 *a = 50; // ok
 a++; // error
}
```

Los datos referenciados por el puntero si pueden ser modificados.

#### Uso de const en métodos

Se usa para atributos o parámetros que no deben cambiar.

Siempre usamos el modificador const cuando declaramos miembros
funciones si la función no modifica los datos del objeto:

```vim
void Display() const;
```

Puede generarse un efecto en cadena cuando invocamos métodos
dentro de un método const, todos ellos también deben ser const.

![](/TheusZero/images/post/POO_C++/22.png)

#### Alcance de Variables

Es posible definir variables con visibilidad solo dentro de un bloque.
Un bloque queda descrito por los símbolos { ... }

```vim
{ int i =20;
 a+=i;
}
```

Variables locales existen solo dentro del bloque de código.

#### Referencias

Una referencia es un **alias** para algún objeto existente.

Físicamente, la referencia almacena la dirección del objeto que
referencia

En el ejemplo, cuando asignamos un valor a rN, también estamos
modificando N:

![](/TheusZero/images/post/POO_C++/23.png)

> cualquier cambio en el contenido de Rn sera reflejado en N y viceversa, ya que Rn es una referencia de N.

#### Verificación de pre-condiciones con assert (afirmar)

La macro assert() puede ser llamada cuando se desee garantizar
absolutamente que se satisface alguna condición. Chequeo de rango
es común:

```vim
double future_value(double initial_balance, double p, int nyear) {
   assert( nyear >= 0 ); // es útil para depuración de programas
   assert( p >= 0 );
   double b = initial_balance
   * pow(1 + p / (12 * 100), 12 * nyear);
   return b;
}
```

#### assert

Si la expresión pasada a la macro assert() es falsa, el programa se
detiene inmediatamente con un mensaje de diagnóstico del tipo:

```vim
Assertion failure in file mysub.cpp,
 line 201: nyear >= 0
```

Con assert el programa no tiene la posibilidad de recuperarse del
error. 

Para eliminar el efecto de assert se debe compilar el programa con la
definición de NDEBUG para el procesador.

```#define NDEBUG``` // esto omite generar código asociado a assert.

## Funciones y Clases Amigas (Friend) Miembros Estáticos (Static)

#### Funciones y Clases Friend

El calificador **friend** se puede aplicar a **funciones globales** y **clases** para otorgar
acceso a miembros privados y protegidos de una clase.

La función función global “friend” tendrá acceso a los miembros como si fuera un
método de la clase.

Una clase B es friend de otra A cuando sus métodos tiene acceso a los miembros
privados y protegidos de la clase A que la ha declarado friend.

![](/TheusZero/images/post/POO_C++/24.png)

#### Implementación de ValidateCourseData()

El calificador friend no aparece en la implementación de la función
global

Notar el acceso a miembros privados (nCredits) de la clase. Esto
es posible por ser función amiga.

```vim
bool ValidateCourseData(const Course & C) {
     if( C.nCredits < 1 || C.nCredits > 5 )
         return false;
     }
  return true;
}
```

![](/TheusZero/images/post/POO_C++/25.png)

#### Clases Friend: clases amigas

![](/TheusZero/images/post/POO_C++/26.png)

La “Amistad” no es mutua. En el ejemplo previo, los métodos de
YourClass no pueden acceder a miembros privados de
YourOtherClass

La “Amistad” no se hereda; esto es, clases derivadas de
YourOtherClass no pueden acceder a miembros privados de
YourClass. Tampoco es transitiva; esto es clases que son “friends”
de YourOtherClass no pueden acceder a miembros privados de
YourClass.

La “amistad” es importante en sobrecarga de operador <<, para
escritura a pantalla pues en este caso no podemos agregar
sobrecargas a clases estándares. Ver ejemplo [CVectorFriend](http://profesores.elo.utfsm.cl/~agv/elo329/C++Prog/CVectorFriend/)

#### Static: Miembros Estáticos

**No hay gran diferencia con Java**

Estas variables tienen existencia desde que el programa se inicia
hasta que termina.

> Atributos estáticos
>> El atributo es compartido por todas las instancias de la clase. Todas las instancias de la clase comparten el mismo valor del atributo estático. Igual que en Java

> Métodos Estáticos
>> Estos métodos pueden ser invocados sobre la clase, no solo sobre una instancia en particular. Igual que en Java.
>
>> El método sólo puede acceder miembros estáticos de la clase

Es posible pensar en miembros estáticos como atributos de la clase
y no de objetos. Hasta aquí igual a Java.

#### Declaración de Datos Estáticos

La palabra clave **static** debe ser usada

```vim
class Student {
    //...
private:
     static int m_snCount; //instance m_snCount
};
```

#### Creación de un contador de instancias

La inicialización de un dato estático no se efectúa en el
constructor pues existe previo a la creación de cualquier objeto

En Java lo hacíamos en bloque de iniciación static
static { ….. }

La iniciación de atributos estáticos es una diferencia entre C++ y
Java.

![](/TheusZero/images/post/POO_C++/27.png)

Usamos el constructor y destructor para incrementar y
decrementar el contador:

![](/TheusZero/images/post/POO_C++/28.png)

#### Métodos Estáticos

Usamos métodos estáticos para permitir el acceso público a
miembros de datos estáticos sin necesidad de instanciar la clase.

![](/TheusZero/images/post/POO_C++/29.png)

#### Llamando a Métodos Estáticos

Como en java, usamos ya sea el nombre de la case o una
instancia de la clase para acceder al método:

![](/TheusZero/images/post/POO_C++/30.png)

## Manejo de Punteros y objetos en memoria dinámica en C++

#### Asignación Dinámica de Memoria

Asignación Dinámica de memoria es la creación de un objeto mientras el
programa está en ejecución. Para ello se usa el operador **new**.

Esta es la única forma usada en Java para crear objetos.

Los objetos creados con new son almacenados en el heap, una gran
espacio de memoria libre gestionado por el sistema operativo.

Cuando objetos son creados de esta manera, éstos permanecen en el heap
hasta que son removidos de él con el operador **delete**

A diferencia de Java, **debemos remover explícitamente los objetos ubicados
en el heap**. Recordar que Java usa el recolector de basura activado por la
máquina virtual.

#### Creando un Objeto en el heap

Usando el operador new, aquí creamos un entero en el heap y asignamos
su dirección a p.

```vim
int * p = new int; 
```

![](/TheusZero/images/post/POO_C++/31.png)

#### Operadores new y delete

```vim
Student * ps = new Student; <--- Llama al constructor Student()
```

El operador new retorna la dirección al objeto recién creado. El operador
delete invoca al destructor y retorna la memoria al heap y deja al objeto no
disponible. 

![](/TheusZero/images/post/POO_C++/32.png)

#### Usando new en Funciones

Si se crea un objeto dentro de una función, lo más probable es que haya
que eliminar el objeto al interior de la misma función. En el ejemplo, la
variable ps se sale del alcance una vez terminado el bloque de la función.

```vim
void MyFunction() {
 Student * ps = new Student; // al término ps desaparece
 // automáticamente, pero el objeto creado no.

 // usamos Student por un rato… luego debemos hacer

 delete ps; // borra el estudiante apuntado por ps
} // antes de borrarlo, se invoca al destructor de Student.
```

![](/TheusZero/images/post/POO_C++/33.png)

#### Memory Leaks (fuga de memoria)

Un **memory leak (o fuga de memoria)** es una condición indeseable creada
cuando un objeto es dejado en el heap y ningún puntero contiene su
dirección. Esto puede pasar si el puntero al objeto queda fuera de alcance:

> ```vim
> void MyFunction() {
>  Student * ps = new Student;
>  // usamos el estudiante ps por un rato
> 
> } // ps sale del alcance
> ```
> 
> (el objeto Student permanecerá en el heap !!! hasta el final del programa, puede
> generar falla por uso total de la memoria si la función es invocada muchas
> veces.)

#### Direcciones retornada por Funciones

Una función puede retornar la dirección de un objeto que fue creado en el
heap.

```vim
Student * MakeStudent()
{
 Student * ps = new Student;

return ps;
} 
```

#### Recibiendo un puntero

El que llama la función puede recibir una dirección y almacenarla en una
variable puntero. El puntero permanece activo mientras el objeto Student
es accesible.

```vim
Student * ps;
ps = MakeStudent();
// Ahora ps apunta a Student
// esto es OK, pero en algún momento hay que
// retornar la memoria.
```

#### Invalidación de Punteros

Un puntero se invalida cuando el objeto referenciado es borrado. Si
tratamos de usar el puntero genera un error de ejecución irrecuperable.

```vim
double * pd = new double;
*pd = 3.523;
delete pd; // luego de esto pd es inválido...
*pd = 4.2; // error! De ejecución.
```

#### Arreglos y Punteros

El nombre de un arreglo es compatible en asignaciones con un puntero al
primer elemento de un arreglo .

![](/TheusZero/images/post/POO_C++/34.png)

#### Arreglos de Punteros

Un arreglo de punteros usualmente contiene la dirección de objetos en
memoria dinámica. Esto ocupa poco almacenamiento para el arreglo y
mantiene la mayor parte de los datos en el heap.

![](/TheusZero/images/post/POO_C++/35.png)

![](/TheusZero/images/post/POO_C++/36.png)

#### Creación de un Arreglo en el heap

Podemos crear arreglos completos en el heap usando el operador
**new**. Hay que recordar eliminarlo cuando corresponda. Para ello
basta incluir **"[ ]"** antes del nombre del arreglo en la **sentencia
delete.**

![](/TheusZero/images/post/POO_C++/37.png)

#### Punteros y Clases

Los punteros son efectivos cuando los encapsulamos en clases porque
podemos controlar su tiempo de vida.

Debemos poner cuidado con la 
**copia baja o copia en profundidad** ya vista
en Java.

![](/TheusZero/images/post/POO_C++/38.png)

#### Punteros en Clases

El constructor crea el arreglo, y el destructor lo borra. 
**De esta forma
pocas cosas pueden salir mal** excepto cuando hacemos una copia de un objeto Student. El
constructor de copia de C++ conduce a problemas.

![](/TheusZero/images/post/POO_C++/39.png)

Por ejemplo, aquí un curso asignado al estudiante X termina en la
lista de cursos del estudiante Y:

![](/TheusZero/images/post/POO_C++/40.png)

#### Paso de parámetros por valor

Cuando usamos paso por valor, la variable local es creada usando el
constructor copia de la clase.

```vim
void foo (Student s) { ….}
// luego usamos
Student Jose;
foo(Jose); // s es inicializado usando Student s(Jose)
```

Esto es importante, **NO creer** que se invoca algo del tipo
```vim
Student s;
s=Jose; 
```

Lo anterior sugiere implementar el constructor copia.

La **acción por omisión del constructor copia y la asignación es copia baja.**

#### Copia en profundidad

Para prevenir este tipo de problemas, creamos un constructor copia que
efectúa una copia en profundidad.

![](/TheusZero/images/post/POO_C++/41.png)

#### Punteros en Clases

Por la misma razón, tenemos que sobrecargar (overload) el operador de
asignación.


>Regla de ORO:
>> Si una clase requiere un
>> constructor copia, también
>> requerirá la sobrecarga del
>> operador asignación e
>> implementación del
>> destructor.

![](/TheusZero/images/post/POO_C++/42.png)

#### Contenedores C++ en Clases

**Cuando usamos contenedores estándares de C++** como listas
y vectores
en una clase, **no hay problema 
con el constructor de copia** porque todos
ellos implementan adecuadamente el 
constructor copia, la asignación y el
destructor.

```vim
class Student {
public:
 Student();
private:
 vector<string> courses;
};
```

## Desarrollo en Qt

Qt (pronunciado como ¸cute”) es un framework de desarrollo de aplicaciones con
multiples bibliotecas

Creado por Haavard Nord y Erick Chambe-Eng en 1995 (primer release)
Desarrollado sobre C++ inicialmente, pero en la actualidad es posible utilizarlo en
otros lenguajes (Ej: PyQt para Python).

Provee mejoras a las bibliotecas nativas de C++ y permite que c´odigos desarrollados
sobre estas bibliotecas sean compatibles con m´ultiples plataformas (mismo concepto
que se aplicaba en Java).

![](/TheusZero/images/post/POO_C++/43.png)

El codigo se construye sobre bibliotecas Qt y sus distintas herramientas de desarrollo

Estas a su vez generan una abstraccion para ejecucion multiplataforma

![](/TheusZero/images/post/POO_C++/44.png)

> Existen dos tipos de modulos en Qt:
> 
> Modulos Core-Essential: Son los que dan forma a Qt. Son parte del desarrollo de estas
> bibliotecas.
>> Ejemplos de modulos core-essential: QtCore, QtGui, QtWidgets, etc.
>
> Modulos add-ons (agregados): Son c´odigos externos al desarrollo de Qt. Depende de
> las contribuciones de usuarios externos activos en el proyecto.
>> Ejemplo de m´odulos add-ons: Qt3D, QtBluetooth, QtSensors, etc

Qt al ser un conjunto de bibliotecas, pueden ser integradas en cualquier IDE que lo
permita. Incluso, es posible compilar programas Qt sin IDE

Qt Creator es un IDE multiplataforma para desarrollo de programas en C++ creado
por el equipo de desarrollo de Qt. Esta orientado principalmente a crear aplicaciones
graficas facilmente utilizando las bibliotecas de desarrollo que provee Qt

> Qt Creator esta compuesto por:
> 
> Editor de texto: Este posee varias funcionalidades, como autocompletado, revision de
> sintaxis, identacion automatica, etc.
> 
> Qt Designer: Para creacion de interfaces graficas de forma sencilla.
>
> Otras funcionalidades (Ej: Debug, conexi´on con sistemas de versionamiento (GIT,
> SVN, otros), etc.)

#### Elementos de Qt en un proyecto

Headers|Sources|Forms|Archivo.pro

![](/TheusZero/images/post/POO_C++/45.png)

![](/TheusZero/images/post/POO_C++/46.png)

![](/TheusZero/images/post/POO_C++/47.png)

![](/TheusZero/images/post/POO_C++/48.png)

![](/TheusZero/images/post/POO_C++/49.png)

![](/TheusZero/images/post/POO_C++/50.png)

#### Signal y Slots

Permiten la comunicaci´on entre objetos de tipo QObject

Una senal (signal) es emitida por un objeto para senalar un evento o cambio de
interes particular ocurre

Una ranura (slot) es un m´etodo que es llamado en respuesta a una se˜nal particular.

Una clase puede tener tanto signals como slots.

![](/TheusZero/images/post/POO_C++/51.png)

> Signal
> 
> Son funciones/metodos de acceso publico que no deben ser implementadas y no
> retornan valores
> 
> Senales son emitidas por un objeto para senalar algun evento de interes (definido por
> el programador).

> Slot
> 
> Son funciones/metodos que pueden ser llamados normalmente. Su unica diferencia es
> que se pueden conectar con signals.
> 
> Un slot es llamado cuando la senal o las senales a las que esta conectado son emitidas

![](/TheusZero/images/post/POO_C++/52.png)

#### Creando GUI

> Qt Widgets
> 
> Equivalente a Node de JavaFX
> 
>>  Permite acceder a los elementos graficos incluidos en las bibliotecas Qt, tanto layouts
>>  como definicion de ventanas, etc.
> 
>  Algunos elementos graficos que heredan de QWidget:
> 
>>  QLabel
> 
>>  QPushButton
> 
>>  QGraphicsLayout
> 
>>  etc

> Clase QPainter
> 
> Permite realizar pintados de bajo nivel de elementos graficos, generalmente sobre
> widgets.
> 
> Su uso comun es dentro del metodo paintEvent de un widget. paintEvent le dice a la
> clase que debe hacer cuando se pinta el widget.

![](/TheusZero/images/post/POO_C++/53.png)

![](/TheusZero/images/post/POO_C++/54.png)

#### QGraphicsView y QGraphicsScene

QPainter es una clase que permite dibujar a muy bajo nivel,
por lo que no permite
crear elementos graficos con muchas propiedades

Podemos crear elementos graficos con mayor autonomia
al crearlos sobre una vista.

QGraphicsView es donde se muestran los elementos graficos.

QGraphicsScene es la clase que controla como se desplegaran.

Una QGraphicsView tiene asociada una 
QGraphicsScene que la controla.

A la vista se le pueden agregar distintos 
elementos graficos (QGraphicsItem) a traves
de la QGraphicsScene.

Los QGraphicsItem agregados pueden 
ser los que provee Qt o personalizados
heredando de QGraphicsItem.

> Ejemplo QGraphicsScene: Pintar un elemento personalizado
> ![](/TheusZero/images/post/POO_C++/55.png)

#### Animaciones

Metodo advance

El metodo “advance” es un metodo slot
de la clase QGraphicsScene y esta asociado
con la actualizacion de items en la escena.

La actualizacion se hace en dos etapas:
En la primera etapa se notifica a 
todos los elementos de la escena que esta va a cambiar
(phase=0)

En la segunda etapa, se notifica a los items
de la escena que se pueden mover
(phase=1).

El metodo advance, al ser llamado,
llama a todos los metodos advance de cada uno de
los elementos QGraphicsItem de la escena

![](/TheusZero/images/post/POO_C++/56.png)

#### Interfaces QML

Qt Quick o QtQuick es el termino
utilizado para una tecnologia de creacion de interfaces de
usuario utilizada en Qt

Es alternativo a QWidget

Se utiliza principalmente en el desarrollo de aplicaciones moviles

> Esta compuesto principalmente por
> 
>> Archivos QML: Archivos de etiquetado tipo JSON para definicion de la interfaz
>
>> JavaScript: Para acciones producidas por la interfaz
>
>> Qt C++: Codigo detras de la logica del programa

#### Licencias de desarrollo Qt

Dependiendo del tipo de producto que se desee desarrollar, Qt se puede usar bajo
diferentes licencias de desarrollo.

Existen dos tipos de licencias de desarrollo:

>> Licencia comercial: Utilizada para desarrollo de aplicaciones de codigo cerrado
> 
>> Licencia GNU Lesser General Public License (LGPL) v3: Licencia utilizada para
> desarrollo de aplicaciones de codigo abierto.
> Ojo ¡Que sean de codigo abierto no quiere decir que no se puedan comercializar!
>
> Qt ademas contiene codigos con licencias especificas asociadas al autor del mismo.
> Cuando se desarrollan aplicaciones con fines comerciales, es critico revisar las licencias
> de las bibliotecas utilizadas (esto bajo cualquier contexto de desarrollo)

## Herencia en C++

#### Motor y ElectricMotor

![](/TheusZero/images/post/POO_C++/57.png)

![](/TheusZero/images/post/POO_C++/58.png)

![](/TheusZero/images/post/POO_C++/59.png)

#### Creación de Clases Derivadas

![](/TheusZero/images/post/POO_C++/60.png)

![](/TheusZero/images/post/POO_C++/61.png)

#### Inicialización de Clase Base

Para inicializar los atributos definidos en la clase base se llama al
constructor de la clase base. En este ejemplo, el número ID del motor
es pasado al constructor de CMotor.

![](/TheusZero/images/post/POO_C++/62.png)

#### Llamando a métodos de la clase base

![](/TheusZero/images/post/POO_C++/63.png)

#### Función o método Display

La función Display funciona de la misma manera. Ésta llama a
CMotor::Display primero.

![](/TheusZero/images/post/POO_C++/64.png)

#### Probando Clases

Cuando el mismo nombre de método existe en ambas clases, **C++ llama
al método implementado para la clase según la declaración del objeto.**
Éste es el caso con los métodos Input y Display (es lo esperable):

```vim
CElectricMotor elec; // CelectricMotor
elec.Input(); // CElectricMotor
elec.Display(); // CElectricMotor
```

#### Asignación de Objetos

Podemos asignar objetos de clases derivadas a un objeto de la clase
base. Similar a Java aunque esto no exista en Java (porque los nombres
son referencias).

![](/TheusZero/images/post/POO_C++/65.png)

Pero no podemos asignar una instancia de una clase base a una instancia
de una clase derivada (similar restricción en Java). Algunos campos de la
clase derivada no existen en la clase base. 

![](/TheusZero/images/post/POO_C++/66.png)

#### Acceso a miembros Protected (Protegidos)

Miembros de una clase designados como protected son visibles a ambas:
la clase actual y las clases derivadas (y a clases amigas -friend- pero a
nadie más). **Es análogo a Java.**

```vim
class CMotor {
public:
 CMotor() { }
 CMotor( const string & id );
protected:
 string get_ID() const;
 void set_ID(const string & s);
//...
}
```

#### Herencia Protegida

Supongamos por un momento que CMotor usa miembros públicos
para todos sus métodos:

```vim
class CMotor {
public:
 CMotor() { }
 CMotor( const string & id );
 string get_ID() const;
 void set_ID(const string & s);
//...
}
```

#### Herencia Protegida

Podemos usar el calificador **protected** cuando creamos una clase
derivada

Con herencia protegida, todos los **métodos
públicos** en la clase
base **pasan a** ser **protegidos**
en la clase derivada. Los restantes
mantienen su nivel de acceso.

```
class CElectricMotor : protected CMotor {
 //...
};
```

#### Herencia Protegida

Por ejemplo, el programa principal no puede llamar set_ID y get_ID
en un motor eléctrico porque ahora esos métodos son protegidos para
instancias de motor eléctrico.

![](/TheusZero/images/post/POO_C++/67.png)

#### Herencia Privada

La herencia privada causa que todos los métodos declarados en la clase
base tienen acceso privado en la clase derivada.

Pareciera que no hay diferencia con herencia protegida: En ambos casos,
métodos de CElectricMotor pueden acceder a métodos de CMotor

```vim
class CElectricMotor : private CMotor {
 //...
 };
```

#### Herencia Privada

Pero cuando derivamos una nueva clase (CPumpMotor) de
CElectricMotor, la diferencia se hace notar: con herencia privada,
métodos en CPumpMotor no pueden acceder a miembros públicos de
CMotor.

```vim
class CPumpMotor : public CElectricMotor {
public:
 void Display() {
     CMotor::Display(); // not accessible!
     CElectricMotor::Display(); // this is OK
 }
};
```

#### Miembros que no son heredados

El constructor y destructor de la clase base no son heredados, deben ser
definidos en la clase heredada.

El constructor por omisión y el destructor sí son llamados cuando se crea
o destruye una instancia de la clase derivada.

Si la clase base tiene sobrecargado el operador =, éste no se hereda en la
clase derivada.

La relación de “amistad” no se hereda. Las clases y funciones friend no
son friend en la clase hija.

Si se omite el nivel de acceso en clases, equivale a poner private

struct es una palabra reservada que puede ser usada en lugar de la
palabra reservada class. La principal diferencia es que al omitir el
nivel de acceso, se entiende público y no privado como con class.

## Polimorfismo en C++, ligado dinámico y Métodos Virtuales, Casting, Declaración incompleta de clases

#### Jerarquía de clases Motor

Recordemos la jerarquía de clases establecida para el estudio
sobre Herencia:

![](/TheusZero/images/post/POO_C++/68.png)

#### Clase CMotor

La definición de la clase CMotor:
```vim
class CMotor {
public:
   CMotor() { }
   CMotor( const string & id );
   string get_ID() const;
   void set_ID(const string & s);
   void Display() const;
   void Input();
private:
   string m_sID;
}; 
```

#### Clase CElectricMotor

![](/TheusZero/images/post/POO_C++/69.png)

#### Clase CGasMotor

![](/TheusZero/images/post/POO_C++/70.png)

#### Punteros a objetos de clases derivadas y referencias a objetos derivados

Es fácil definir objetos dinámicos de una clase derivada usando
un puntero de tipo específico:

![](/TheusZero/images/post/POO_C++/71.png)

#### Polimorfismo

Análogo a Java, en C++ podemos declarar punteros a una clase base, y
luego asignarle la dirección de una instancia de una clase derivada. **Este
caso es normal en Java.** Es el principio de sustitución en C++. Esta
técnica es un tipo de polimorfismo.

*Recordar: Polimorfismo es un concepto donde, en una de sus
formas, un mismo nombre puede referirse a objetos de clases
diferentes que están relacionadas por una clase base común.*

```vim
CMotor * pM;
 pM = new CElectricMotor; // puntero a motor eléctrico
 // semántica similar a Java
 CElectricMotor em;
 CMotor & motor = em; // referencia a motor eléctrico
 // esta opción no existe en Java
```

![](/TheusZero/images/post/POO_C++/72.png)

#### Ligado dinámico

En C++ la opción por **omisión
es llamar el método definido por el tipo del
puntero o referencia**,
no el tipo del objeto apuntado. Esto es **Distinto a
Java!**

![](/TheusZero/images/post/POO_C++/73.png)

#### Métodos Virtuales (Virtual)

**Si deseamos tener un comportamiento como Java, debemos declarar
los métodos Input y Display como virtuales en la clase base.**

El calificador virtual le dice al compilador que genere código que mire al
tipo del objeto apuntado (no del puntero) en tiempo de ejecución y use
esta información para seleccionar la versión apropiada del método.

El ligado dinámico **aplica cuando usamos punteros o referencias** a
objetos.

```vim
class CMotor {

 virtual void Display() const; // el calificador virtual cambia
 virtual void Input(); // la forma de definir el código
 // a ser finalmente invocado.

};
```

#### Métodos Virtuales

Es recomendable definir también como virtuales los métodos en la
clase derivada, en este caso en las clases CGasMotor y
CElectricMotor.

```vim
class CGasMotor :public CMotor {
public:
 ...
 virtual void Display() const;
 virtual void Input();
 ...
};
```

De esta forma la semántica del método se mantiene entre clases
heredadas.

Ahora los métodos Display e Input son llamados usando ligado
**dinámico** desde la clase CElectricMotor:

```vim
CMotor * pM;
pM = new CElectricMotor;

pM->Input(); // CElectricMotor::Input()
pM->Display(); // CElectricMotor::Display()
```

#### Métodos Virtuales

A menudo, un puntero será pasado como argumento a una función
que espera un puntero a objeto de la clase base.

Cuando el método es llamado, podemos pasar cualquier puntero como
parámetro actual, siempre y cuando éste apunte a una instancia
derivada de la clase base (“subtipo”).

![](/TheusZero/images/post/POO_C++/74.png)

Ejemplo de llamados a GetAndShowMotor con diferentes tipos de
punteros.

![](/TheusZero/images/post/POO_C++/75.png)

#### (Salida de la lámina previa)

![](/TheusZero/images/post/POO_C++/76.png)

#### Creación de un vector de Motores

![](/TheusZero/images/post/POO_C++/77.png)

#### Acceso a Vector de punteros

La función que despliega tales vectores no necesita saber
exactamente qué tipo de puntero están en el vector mientras se
llame a métodos virtuales.

![](/TheusZero/images/post/POO_C++/78.png)

#### Salida de la función ShowVector

La función ShowVector llama a la versión apropiada del método
virtual Display() para cada puntero en el vector.

```vim
------- Vector of Motor Pointers -------
1: [ElectricMotor] ID=10000, Voltage=110
2: [GasMotor] ID=20000, Cylinders=4
3: [ElectricMotor] ID=30000, Voltage=220
4: [GasMotor] ID=40000, Cylinders=2
```

#### Liberación de almacenamiento

Debemos liberar el almacenamiento usado por cada objeto motor.
Este bucle remueve los punteros uno por uno.

```vim
for(int i=0; i < vMotors.size(); i++) {
    delete vMotors[i]; // delete each motor
}
```

El operador delete accede a información que le permite saber
exactamente cuánto almacenamiento liberar por cada puntero (aún
cuando los motores ocupan distintos tamaños).

> Saber distinguir lo previo de:
> ```vim
> CMotor * motor = new CMotor [40];
> delete [] motor; // aquí el arreglo está en el heap.
> ```

#### Métodos Virtuales Puros

Un método virtual puro no tiene implementación. Esto es identificado en
C++ con un "= 0" al final de la declaración

Un método virtual puro **requiere** que la función sea implementada en la
clase derivada.

> Es **equivalente a los métodos abstractos en Java**
> 
> ```vim
> class CMotor {
> public:
> //...
>   virtual void Display() const = 0; // => no está implementado
>   virtual void Input() = 0; // => no está implementado
> //...
> }
> ```

#### Clases Abstractas (Abstract Classes)

Una clase que contiene uno o más métodos **virtuales** puros pasa a
ser una clase **abstracta**.

Por igual razón que en Java, NO es posible crear instancias de una
clase abstracta, pero en **C++ no requiere calificador “abstract”.**

```vim
Con la declaración previa para CMotor:
CMotor M; // error
CMotor * pM = new CMotor; // error
```

#### Conversiones Implícitas datos

C++ maneja conversiones automáticamente en el caso de tipos
numéricos intrínsecos (int, double, float)

> Mensajes de advertencia (warning) pueden aparecer cuando hay
> riesgo de pérdida de información (precisión).
>
> Hay variaciones de un compilador a otro

**Ejemplos**

![](/TheusZero/images/post/POO_C++/79.png)

#### Operación cast

Una operación de “casteo” cast convierte explícitamente datos de un
tipo a otro.

Es usado en conversiones “seguras” que podrían ser hechas por el
compilador. 

Son usadas para abolir mensajes de advertencia (warning
messages).

El operador tradicional de C pone el nuevo tipo de dato entre
paréntesis. C++ mejora esto con una operador cast tipo función.

**Ejemplos de cast**

![](/TheusZero/images/post/POO_C++/80.png)

#### Nueva forma de hacer “casteo” en C++: **static_cast<> y dynamic_cast<>**

El operador static_cast<> es la forma preferida para hacer
conversiones “seguras” en C++

Éste reemplaza el operador tradicional de C y el estilo función de
C++.

Existe también el dynamic_cast<>, éste asegura que el resultado
de la conversión es un dato compatible. Sólo se aplica a punteros
a objetos.

dynamic_cast<> lanza error cuando el resultado de la conversión
no es un objeto completo de la clase requerida.

#### Ejemplos de static_ y dynamic_cast

> static_cast
> ![](/TheusZero/images/post/POO_C++/81.png)

> dynamic_cast
> ![](/TheusZero/images/post/POO_C++/82.png)

#### Declaración incompleta de clases

En ocasiones podemos tener este tipo de dependencias:

![](/TheusZero/images/post/POO_C++/83.png)

![](/TheusZero/images/post/POO_C++/84.png)

![](/TheusZero/images/post/POO_C++/85.png)

## Licencias de Software

#### ¿Que es una licencia de software?

Es un acuerdo legal entre el creador de un software y su usuario
que limita las cosas permitidas hacer

> Una licencia de software responde preguntas como:
> 
> ¿Donde, como y que tan frecuentemente puedo instalar el
> programa?
> 
> ¿Puedo copiarlo, modificarlo o redistribuirlo?
> 
> ¿Puedo mirar su codigo fuente?

No cumplir con este acuerdo legal corresponde a una infraccion
a la ley de derechos de autor

#### ¿Que son los derechos de autor?

Protege los derechos que un autor adquiere sobre la creaci´on de
una obra.

> Existen tres tipos de derechos de autor:
> 
> ![](/TheusZero/images/post/POO_C++/86.png)

#### Tipos de licencias

Algunas de las licencias m´as populares en la actualidad son:

> Sin licencia: Codigos sin licencia tienen copyright por omision.
> Usuarios no tienen derecho a usar el codigo sin permiso explıcito
> de su autor.

> Propietaria: Licencias mas restrictivas, las cuales solo permiten
> el uso de un programa, pero no su modificacion o redistribucion.
> Ej. MS Reference.

> GNU GPLv3: Permisos de utilizacion o modificacion del codigo,
> deben venir acompanadas con la liberacion del nuevo codigo
> fuente generado. Posee copyleft

> GNU LGPLv3: Licencia utilizada por Qt. Identica a la GNU
> 
> GPLv3. Proyectos que utilicen un codigo bajo esta licencia solo
> como biblioteca dinamica, pueden saltarse el copyleft y licenciar
> bajo licencias mas restrictivas.

> MIT License: Licencia permisiva. Utilizar codigo bajo esta
> licencia en un proyecto, solo requiere que se incluya una
> notificacion de la licencia utilizada dentro del software.
> 
> WTFPL: Licencia mas permisiva. “Haz lo que te de la gana”.

#### Uso de licencias

Determinar inicialmente bajo que modalidad quieres licenciar tu
software. Esto determinara que herramientas puedes utilizar y
cuales no.

Tanto para el lenguaje utilizado como para las bibliotecas
incluidas en tu desarrollo, verificar las licencias de cada una y la
compatibilidad con tu modalidad de licencia.

Verificar la compatibilidad de licencias entre los distintos
elementos de tu software. Pueden haber bibliotecas con licencias
incompatibles entre si.

Que algo sea codigo abierto ¡NO quiere decir que sea gratuito!
Ej: Red Hat Linux

Ante cualquier duda, siempre consultar con un abogado.



