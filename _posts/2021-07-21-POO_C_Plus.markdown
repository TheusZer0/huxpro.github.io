---
layout: post
title: "POO para C++"
subtitle: 'POO para C++'
date: 2021-07-21 12:00:00
author: "TheusZero"
header-img: "images/post/PythonAutoayuda/solarized-wallpaper-python.png"
catalog: true
comments: true
tags:
    - Programacion
    - Python
    - USM
    - Tareas
    - Java
    - C++
---

![](/TheusZero/images/post/POO/63.png)

## Programacion en C++ Links

[]()

[]()

## Introducción a C++

diapositiva 1:

#### C++ vs C


> C++ es un lenguaje posterior a C

> C++ mantiene todo el poder de C agregando características que
facilitan la programación. C++ es compatible hacia atrás con C.

> C++ permite la programación orientada a objetos y, como las
últimas versiones de Java, permite programación genérica. A
diferencia de Java, C++ permite  crear programas en el paradigma
procedural u orientado a objetos según se necesite. ¡Incluso
mezclas entre ellos!

> C++ posee una biblioteca de funciones más amplia que C. Las
bibliotecas ya existentes de C son en su mayoría compatibles con C++

#### C++ vs Java

C++ es plataforma dependiente (Bibliotecas como Qt buscan resolver este
problema).

> C++ soporta herencia múltiple.

> C++ soporta sobrecarga de operadores (Ej: es posible dar nuevas funcionalidades
> al operador “+”).

> Mientras Java utiliza punteros, C++ soporta el uso de éstos y operaciones sobre los
> mismos de forma explícita.

> C++ soporta tanto llamadas (o paso de parámetros) por valor como por referencia,
> mientras Java solo soporta llamadas por valor

> No existe un equivalente nativo para documentación en C++ como lo hay en Java
> (Javadoc). Se puede usar Doxygen.

> C++ crea nuevos árboles de herencia en cada programa. Java tiene un solo árbol
de herencia, pues todo hereda de la clase Object.


#### Proceso de compilación en C++

> Involucra tres pasos:
>
> Preprocesamiento: El pre-procesador toma el archivo del código fuente y procesa todas las directivas
que comienzan con # (#include, #define, etc). La salida es un archivo C++ puro.
> 
> Compilación: el compilador toma la salida del pre-procesador y genera un archivo objeto (primero
assembler y luego binario de extensión .o) por cada archivo de código fuente ejecutable.
> 
> Ligado (linking): toma los archivos generados por el compilador y produce un archivo ejecutable (o
una biblioteca -no en este curso-)

![](/TheusZero/images/post/POO_C++/1.png)

#### Archivos de encabezado

ELO329 Diseño y Programación Orientados a Objetos 5
Archivos de encabezadoSon necesarios para declarar prototipos y definir constantes usadas en el programa.

Son incluidos con la directiva del pre-procesador

```#include```

Ejemplo:

```vim
#include <vector>
#include <sys/socket.h>
#include “setup.h”
```

Al usar <....> la búsqueda del archivo se hace en lugares “estándares” definidos por el
compilador.

Los directorios estándares varían en cada instalación. Para ver cuáles son en tu
sistema, puedes usar:

```vim
$ touch a.c  // o el comando para crear un archivo a.c vacío.$ gcc -v -E a.cMostrará los directorios a buscar para archivos 

#include <...>    e
#include “...”

```

#### Tipos de variables

```vim
int
short int ( o short)
long int (o long)
unsigned int (o unsigned)
unsigned long int (o unsigned long)
unsigned short int (unsigned short)
char 
float
double
long double
bool
```

#### Acceso de Variable

**Las variables en C++ como en C, representan a los valores en sí y no
referencias a éstos**. En Java esto es así sólo para los tipos simples escalares
como int, float, double, char y boolean.

La diferencia entre C++ y Java se hace notar al manejar objetos

Objetos en Java son referencias a éstos y todos se encuentran en el heap.
Mientras que en C++ los nombres de objetos siempre se refieren al objeto mismo
y se pueden encontrar en el heap, en stack o en segmentos de datos de la
memoria.

> ```vim
> //Ej: en C++
> 
> Empleado juan, pedro; // al momento de crear la variable ya se
>  // crea el objeto invocando el constructor. Distinto de Java
>  
> juan=pedro; // hace que juan tome todos los atributos de pedro.
> ```
> 
> Un cambio posterior a juan no afecta a pedro.
>
> Ésta es una gran diferencia con la semántica en Java

#### Salida de Datos

iostream debe ser incluido para hacer uso de las operaciones de entrada y
salida.

```vim
#include <iostream>
using namespace std; // para usar el objeto cout
int main (void){
 cout << “Hello, world” << endl;
 return 0;
}
```

Es posible enviar datos a la salida estándar o a archivos:

```vim
#include <fstream>
ofstream os (“output.dat”);
os << “The value of pi is approx. “ << 3.14159 << endl;
```

```vim
#include <iostream>
#include <fstream>
using namespace std;
int main() {
int i;
ifstream fin;
fin.open("test"); // test contains 3 ints
for (int j=0;j<3;j++) {
fin >> i;
cout << i << endl;
}
fin.close();
}
```

#### Lectura desde archivo: Ejemplo

```vim
#include <string>
#include <fstream>
#include <iostream>
using namespace std;
int main() {
 string s;
 ifstream fin;
 fin.open("/etc/passwd");
 while(getline(fin,s))
 cout << s << endl;
}
```

#### Operadores aritméticos

![](/TheusZero/images/post/POO_C++/2.png)

#### Asignaciones, Arreglos y Vectores

Todas asignación tiene un valor, aquel asignado. Ej: a=b=c;

ANSI C++ usa el mismo constructor de arreglo que C

Como los arreglos de C no son particularmente poderosos,
C++ incorpora vectores (no corresponde al concepto de vector
geométrico). Éstos son análogos a los ArrayList de Java.

Los vectores son una forma de plantilla (template). Una plantilla es una
declaración de clase con un tipo de dato como parámetro, su uso es
simple:
vector <X> a(n); // Ojo aún no usamos new como en Java...
crea un arreglo “crecedor” de elementos de tipo X con espacio para n
elementos.

El acceso es con: a[i]

#### Vectores

Pueden crecer según nuestra necesidad ```vector <double> a;```

En este caso a está vacío. Para hacerlo crecer:

```vim
a.push_back(0.3);
a.push_back(56.2);
```

También podemos hacer que el vector crezca en varios elementos: ```a.resize(10);```

Podemos preguntar por el tamaño de un vector con a.size(); como en:

```vim
for (int i=0; i < a.size(); i++)
 // ..... por más detalles ver www.cplusplus.com
```

#### Strings

En ANSI C++ tenemos acceso a una clase poderosa para string.

Ésta tiene definido el operador copia =, el operador concatenación +
y operadores relacionales ==, !=, <, <=, >, >=, entre otros.

El operador [ ] provee acceso a elementos individuales.

Existen muchos métodos en esta clase como substr para extraer un
substring:

```vim
string s = “Hola a todos”;
int n = s.length(); // asigna 12
char ch = s[0];
string t = s.substr(0,4); // Substring de s[0] a s[4]
```

#### Control de Flujo

Se dispone de las opciones comunes en otros lenguajes:

```vim
if (condición)
    block1 // Un bloque de instrucciones se delimita con { }
else
    block2
    La parte else es opcional.

while (condición) block 
do
    block
while (condición);

for(expresión; expresión2; expresión3)
    instrucción_a_repetir 

switch : análogo a Java
```

#### Punteros (resumen)

Toda variable tiene un cierto valor o estado y una dirección de
memoria asociada.

![](/TheusZero/images/post/POO_C++/3.png)

Las variables punteros, tienen almacenada la dirección en memoria
de otra variable o dato.

Definición en C/C++: Para definir una variable como puntero, se
utiliza el operador “*”

```vim
 int *pVar; // pVar almacena una dirección de memoria para alojar un entero
```

A una variable de tipo puntero, almacena la dirección de memoria
de otra variable. Para obtener la dirección de una variable en C/C++
se utiliza el operador “&”

![](/TheusZero/images/post/POO_C++/4.png)

Es posible obtener el valor de la variable a la cual se apunta
utilizando el operador “*”:

> ```cout << &pVar <<endl; // Imprime la dirección de pVar (3571)```
> 
> ```cout << pVar << endl; // Imprime el contenido de pVar (1776)```
> 
> ```cout<< *pVar <<endl; // Imprime el valor del contenido apuntado (5)```


>> Operadores:
>
> Operador de dereferencia (*): Permite acceder al valor de aquella variable a la
> que se apunta
>
> Operador de referencia (&): Permite obtener la dirección de memoria de la
> variable solicitada

#### Paso por referencia

En C++ tenemos un nuevo tipo de paso de argumentos, el paso por referencia.

El efecto es equivalente al uso de punteros en C. La sintaxis cambia.

En C se puede hacer:

> ```vim
> void swap_en_C(int * px, int * py){
>     int tmp = *px;
>     *px = *py;
>     *py=tmp;
> }
> ```
> El llamado es swap_en_C(&a, &b)

> Ahora en C++, tenemos la opción anterior y una más simple:
> ```vim
> void swap_en_Cplusplus (int & x, int & y){
>     int tmp = x;
>     x=y;
>     y=tmp;
> }
> ```
> El llamado es swap_en_Cplusplus(a,b);

> Obviamente:
>> ```swap_enCplusplus(4,x);``` // no es legal
>> ```swap_enCplusplus(i+2,j-1);``` // no es lega

![](/TheusZero/images/post/POO_C++/5.png)


## Clases y objetos en C++

El concepto de clase y objeto ya visto para Java no cambia en C++. Estos
conceptos son independientes del lenguaje

Lenguaje: en los textos de C++ es común referirse a los atributos como los
**miembros dato** de la clase y a los métodos como **miembros función**

Mientras en Java todos los objetos son creados y almacenados en el Heap
(o zona de memoria dinámica), en C++ los objetos se pueden ubicar en
stack (zona de memoria dedicada al proceso y determinada durante
compilación) o en memoria dinámica (solicitada durante ejecución).

Al definir un objeto estáticamente en C++, su creación queda determinada.
En cambio, en java se define el nombre y el objeto se crea usando new.

Para crear objetos en el heap, en C++, se usa punteros a objetos y, como
en Java, se crean con new. En este caso cambia la notación pero na
semántica es similar a la de Java.

#### Ubicación de Objetos en C++ (para ir notando diferencia)

![](/TheusZero/images/post/POO_C++/6.png)

#### Estructura Básica de programas C++

En C++ es recomendado separar en distintos archivos la definición de una
clase por un lado y la implementación de ésta en otro archivo.

Se crea un archivo de encabezado “clase.h”, en él podemos la **definición
de la clase**, es decir los atributos y prototipos de métodos.

En otro archivo “clase.cpp” ponemos la **implementación** de cada
método. En este archivo debemos incluir el archivo de encabezado
“clase.h”

Podemos implementar varias clases por archivo y un .h puede tener la
definición de varias clases, pero se recomienda hacer un .h y un .cpp por
cada clase.

#### Estructura de archivos

![](/TheusZero/images/post/POO_C++/7.png)

![](/TheusZero/images/post/POO_C++/8.png)

#### Calificadores de Acceso Público y Privado: es similar a Java

> Los miembros precedidos por el calificador public son visibles fuera de la clase
>> por ejemplo, un miembro público es visible desde el main(), como es el caso de cin.get(), cin es el objeto, get es la función de acceso público.
>
>> Es el calificador por omisión en estructuras (uso de struct en lugar de class).

Los miembros precedidos por el calificador **private** quedan ocultos para
funciones o métodos fuera de la clase. **Calificador por omisión en clases**.

Miembros precedidos por **protected** pueden ser accedidos por miembros de la
misma clase y clases derivadas.

Las clases y funciones amigas (más adelante) tienen acceso a todo.

![](/TheusZero/images/post/POO_C++/9.png)

#### Ejemplo: Clase Automóvil

> Imaginemos que queremos modelar un automóvil:
>> Atributos: marca, número de puertas, número de cilindros, tamaño del motor
>
>> Operaciones: fijar y obtener número de puertas, entrada y despliegue de atributos, partir, parar, revisar_gas

![](/TheusZero/images/post/POO_C++/10.png)

#### Clasificación de Funciones Miembros en una Clase

Un **“accesor”** es un método que retorna un valor desde su objeto, pero
no cambia el objeto (sus atributos). Permite acceder a los atributos del
objeto.

Un **mutador** es un método que modifica su objeto

Un **constructor** es un método con el mismo nombre de la clase que se
ejecuta tan pronto como una instancia de la clase es creada.

Un **destructor** es un método el mismo nombre de la clase y una
virgulilla () antepuesta. Ej.: Automobil()

> ejemplo Clase automovil

![](/TheusZero/images/post/POO_C++/11.png)

#### Creando y accediendo un Objeto

![](/TheusZero/images/post/POO_C++/12.png)

#### Constructores: Similar a Java

Un constructor se ejecuta cuando el objeto es creado, es decir, tan pronto
es definido en el programa. Ej. Esto es antes de la función main() en el
caso de objetos globales y cuando una función o método es llamado en el
caso de datos locales.

En ausencia de constructores, C++ define un construcción por omisión, el
cual no tiene parámetros.

Debemos crear nuestro constructor por defecto si tenemos otros
constructores.

Si definimos un arreglo de objetos, el constructor por defecto es llamado
para cada objeto:

```vim
Point drawing[50];  // calls default constructor 50 times
                    // a diferencia de Java aquí ya tenemos 50 Puntos.
```

#### Implementación de Constructores

Podemos implementar un método en la definición de la clase. Se conoce
como código “inline”

Un constructor por defecto para la clase Point podría inicializar X e Y:

```vim
class Point {
public:
    Point() { // función inline , usarla solo si
    m_X = 0; // implementación es simple.
    m_Y = 0;
 } // Ojo no va ; aquí, es el fin del método.
private:
 int m_X;
 int m_Y;
};
```

#### Funciones Out-of-Line

Todos los métodos deben ser declarados (el prototipo) dentro de la
definición de una clase.

La implementación de funciones no triviales son usualmente definidas fuera
de la clase y en un archivo separado, en lugar de ponerlas in-line en la
definición de la clase.

> Por ejemplo para el constructor Point, la implementación “of-line” sería:
> ```vim
> Point::Point() {
>  m_X = 0;
>  m_Y = 0;
> }
> ```

El símbolo **::** permite al compilador saber que estamos definiendo la función
Point de la clase Point. Este también es conocido como operador de
**resolución de alcance ::**

> Clase Automobile (revisión)
> ![](/TheusZero/images/post/POO_C++/13.png)

> Implementaciones de los métodos de Automobile
> ![](/TheusZero/images/post/POO_C++/14.png)

> Implementación del método de entrada
> ![](/TheusZero/images/post/POO_C++/15.png)

#### Constructores

Como en Java, múltiples constructores pueden existir con
diferentes listas de parámetros:

> 1/5: Sobrecarga
> ![](/TheusZero/images/post/POO_C++/16.png)
>
> 2/5: Invocación
> ![](/TheusZero/images/post/POO_C++/17.png)
>
> (3/5): Implementación
> ![](/TheusZero/images/post/POO_C++/18.png)
>
> (4/5): visibilidad de Parámetros
> ![](/TheusZero/images/post/POO_C++/19.png)

> (5/5): Lista de Inicialización
> ![](/TheusZero/images/post/POO_C++/20.png)

#### Destructores

Una diferencia importante con Java es la presencia de destructores. Lo
más cercano en java es el método finalize() (hoy obsoleto) de la clase
Object.

Java tiene un proceso de “recolección de basura” por lo que hace los
destructores no críticos.

En C++ el **destructor se invoca en forma automática** justo antes que el
objeto sea inaccesible para el programa.

El método destructor no tiene parámetros, se llama igual a la clase y lleva
un signo ~ como prefijo.
```Ej: Automobile::~Automobile() {}``` 

## const, referencias (&), y macro assert en C++ 

modificadores que se pueden aplicar al codigo

#### const

es como el final de Java

> Tiene varios usos:
>> Para evitar que una atributo, variable o parámetro cambie. Es mejor que
> #define
>> Para indicar que un método no cambia el estado de un objeto.
>
>> El objeto calificado como constante debe tener un valor asignado en su definición o vía lista de inicialización.

```vim
const int n = 25;
n = 36; // error
const double z; // error
int m = n;
m = 36; 
```

#### Calificador const en punteros

> Hay dos posiciones con distinto resultado.
>> int * const a; // no puedo cambiar a
> 
>> const int *a; // no puedo cambiar el contenido apuntado

```vim
    void MySub( const int *a ) { // Contenido constante!
    *a = 50; // error
    a++; // ok
    }
```

En este ejemplo, el puntero sí puede ser modificado, pero esto no
tiene efecto duradero o posterior ya que el puntero es pasado por
valor (se crea uno local y se copia el valor el parámetro actual).

![](/TheusZero/images/post/POO_C++/21.png)

#### Punteros Constantes

La declaración de un **puntero constante** solo garantiza que el
puntero en sí no pueda ser modificado

```vim
void MySub( int * const a ) { // Puntero constante
 *a = 50; // ok
 a++; // error
}
```

Los datos referenciados por el puntero si pueden ser modificados.

#### Uso de const en métodos

Se usa para atributos o parámetros que no deben cambiar.

Siempre usamos el modificador const cuando declaramos miembros
funciones si la función no modifica los datos del objeto:

```vim
void Display() const;
```

Puede generarse un efecto en cadena cuando invocamos métodos
dentro de un método const, todos ellos también deben ser const.

![](/TheusZero/images/post/POO_C++/22.png)

#### Alcance de Variables

Es posible definir variables con visibilidad solo dentro de un bloque.
Un bloque queda descrito por los símbolos { ... }

```vim
{ int i =20;
 a+=i;
}
```

Variables locales existen solo dentro del bloque de código.

#### Referencias

Una referencia es un **alias** para algún objeto existente.

Físicamente, la referencia almacena la dirección del objeto que
referencia

En el ejemplo, cuando asignamos un valor a rN, también estamos
modificando N:

![](/TheusZero/images/post/POO_C++/23.png)

> cualquier cambio en el contenido de Rn sera reflejado en N y viceversa, ya que Rn es una referencia de N.

#### Verificación de pre-condiciones con assert (afirmar)

La macro assert() puede ser llamada cuando se desee garantizar
absolutamente que se satisface alguna condición. Chequeo de rango
es común:

```vim
double future_value(double initial_balance, double p, int nyear) {
   assert( nyear >= 0 ); // es útil para depuración de programas
   assert( p >= 0 );
   double b = initial_balance
   * pow(1 + p / (12 * 100), 12 * nyear);
   return b;
}
```

#### assert

Si la expresión pasada a la macro assert() es falsa, el programa se
detiene inmediatamente con un mensaje de diagnóstico del tipo:

```vim
Assertion failure in file mysub.cpp,
 line 201: nyear >= 0
```

Con assert el programa no tiene la posibilidad de recuperarse del
error. 

Para eliminar el efecto de assert se debe compilar el programa con la
definición de NDEBUG para el procesador.

```#define NDEBUG``` // esto omite generar código asociado a assert.

## Funciones y Clases Amigas (Friend) Miembros Estáticos (Static)

#### Funciones y Clases Friend

El calificador **friend** se puede aplicar a **funciones globales** y **clases** para otorgar
acceso a miembros privados y protegidos de una clase.

La función función global “friend” tendrá acceso a los miembros como si fuera un
método de la clase.

Una clase B es friend de otra A cuando sus métodos tiene acceso a los miembros
privados y protegidos de la clase A que la ha declarado friend.

![](/TheusZero/images/post/POO_C++/24.png)

#### Implementación de ValidateCourseData()

El calificador friend no aparece en la implementación de la función
global

Notar el acceso a miembros privados (nCredits) de la clase. Esto
es posible por ser función amiga.

```vim
bool ValidateCourseData(const Course & C) {
     if( C.nCredits < 1 || C.nCredits > 5 )
         return false;
     }
  return true;
}
```

![](/TheusZero/images/post/POO_C++/25.png)

#### Clases Friend: clases amigas

![](/TheusZero/images/post/POO_C++/26.png)

La “Amistad” no es mutua. En el ejemplo previo, los métodos de
YourClass no pueden acceder a miembros privados de
YourOtherClass

La “Amistad” no se hereda; esto es, clases derivadas de
YourOtherClass no pueden acceder a miembros privados de
YourClass. Tampoco es transitiva; esto es clases que son “friends”
de YourOtherClass no pueden acceder a miembros privados de
YourClass.

La “amistad” es importante en sobrecarga de operador <<, para
escritura a pantalla pues en este caso no podemos agregar
sobrecargas a clases estándares. Ver ejemplo [CVectorFriend](http://profesores.elo.utfsm.cl/~agv/elo329/C++Prog/CVectorFriend/)

#### Static: Miembros Estáticos

**No hay gran diferencia con Java**

Estas variables tienen existencia desde que el programa se inicia
hasta que termina.

> Atributos estáticos
>> El atributo es compartido por todas las instancias de la clase. Todas las instancias de la clase comparten el mismo valor del atributo estático. Igual que en Java

> Métodos Estáticos
>> Estos métodos pueden ser invocados sobre la clase, no solo sobre una instancia en particular. Igual que en Java.
>
>> El método sólo puede acceder miembros estáticos de la clase

Es posible pensar en miembros estáticos como atributos de la clase
y no de objetos. Hasta aquí igual a Java.

#### Declaración de Datos Estáticos

La palabra clave **static** debe ser usada

```vim
class Student {
    //...
private:
     static int m_snCount; //instance m_snCount
};
```

#### Creación de un contador de instancias

La inicialización de un dato estático no se efectúa en el
constructor pues existe previo a la creación de cualquier objeto

En Java lo hacíamos en bloque de iniciación static
static { ….. }

La iniciación de atributos estáticos es una diferencia entre C++ y
Java.

![](/TheusZero/images/post/POO_C++/27.png)

Usamos el constructor y destructor para incrementar y
decrementar el contador:

![](/TheusZero/images/post/POO_C++/28.png)

#### Métodos Estáticos

Usamos métodos estáticos para permitir el acceso público a
miembros de datos estáticos sin necesidad de instanciar la clase.

![](/TheusZero/images/post/POO_C++/29.png)

#### Llamando a Métodos Estáticos

Como en java, usamos ya sea el nombre de la case o una
instancia de la clase para acceder al método:

![](/TheusZero/images/post/POO_C++/30.png)

## Manejo de Punteros y objetos en memoria dinámica en C++

#### apuntes

> en C solo era
> ![](/TheusZero/images/post/POO_C++/87.png)
>
> En C++ es
> ![](/TheusZero/images/post/POO_C++/88.png)

#### Asignación Dinámica de Memoria

Asignación Dinámica de memoria es la creación de un objeto mientras el
programa está en ejecución. Para ello se usa el operador **new**.

Esta es la única forma usada en Java para crear objetos.

Los objetos creados con new son almacenados en el heap, una gran
espacio de memoria libre gestionado por el sistema operativo.

Cuando objetos son creados de esta manera, éstos permanecen en el heap
hasta que son removidos de él con el operador **delete**

A diferencia de Java, **debemos remover explícitamente los objetos ubicados
en el heap**. Recordar que Java usa el recolector de basura activado por la
máquina virtual.

#### Creando un Objeto en el heap

Usando el operador new, aquí creamos un entero en el heap y asignamos
su dirección a p.

```vim
int * p = new int; 
```

![](/TheusZero/images/post/POO_C++/31.png)

#### Operadores new y delete

```vim
Student * ps = new Student; <--- Llama al constructor Student()
```

El operador new retorna la dirección al objeto recién creado. El operador
delete invoca al destructor y retorna la memoria al heap y deja al objeto no
disponible. 

![](/TheusZero/images/post/POO_C++/32.png)

#### Usando new en Funciones

Si se crea un objeto dentro de una función, lo más probable es que haya
que eliminar el objeto al interior de la misma función. En el ejemplo, la
variable ps se sale del alcance una vez terminado el bloque de la función.

```vim
void MyFunction() {
 Student * ps = new Student; // al término ps desaparece
 // automáticamente, pero el objeto creado no.

 // usamos Student por un rato… luego debemos hacer

 delete ps; // borra el estudiante apuntado por ps
} // antes de borrarlo, se invoca al destructor de Student.
```

![](/TheusZero/images/post/POO_C++/33.png)

#### Memory Leaks (fuga de memoria)

Un **memory leak (o fuga de memoria)** es una condición indeseable creada
cuando un objeto es dejado en el heap y ningún puntero contiene su
dirección. Esto puede pasar si el puntero al objeto queda fuera de alcance:

> ```vim
> void MyFunction() {
>  Student * ps = new Student;
>  // usamos el estudiante ps por un rato
> 
> } // ps sale del alcance
> ```
> 
> (el objeto Student permanecerá en el heap !!! hasta el final del programa, puede
> generar falla por uso total de la memoria si la función es invocada muchas
> veces.)

#### Direcciones retornada por Funciones

Una función puede retornar la dirección de un objeto que fue creado en el
heap.

```vim
Student * MakeStudent()
{
 Student * ps = new Student;

return ps;
} 
```

#### Recibiendo un puntero

El que llama la función puede recibir una dirección y almacenarla en una
variable puntero. El puntero permanece activo mientras el objeto Student
es accesible.

```vim
Student * ps;
ps = MakeStudent();
// Ahora ps apunta a Student
// esto es OK, pero en algún momento hay que
// retornar la memoria.
```

#### Invalidación de Punteros

Un puntero se invalida cuando el objeto referenciado es borrado. Si
tratamos de usar el puntero genera un error de ejecución irrecuperable.

```vim
double * pd = new double;
*pd = 3.523;
delete pd; // luego de esto pd es inválido...
*pd = 4.2; // error! De ejecución.
```

#### Arreglos y Punteros

El nombre de un arreglo es compatible en asignaciones con un puntero al
primer elemento de un arreglo .

![](/TheusZero/images/post/POO_C++/34.png)

#### Arreglos de Punteros

Un arreglo de punteros usualmente contiene la dirección de objetos en
memoria dinámica. Esto ocupa poco almacenamiento para el arreglo y
mantiene la mayor parte de los datos en el heap.

![](/TheusZero/images/post/POO_C++/35.png)

![](/TheusZero/images/post/POO_C++/36.png)

#### Creación de un Arreglo en el heap

Podemos crear arreglos completos en el heap usando el operador
**new**. Hay que recordar eliminarlo cuando corresponda. Para ello
basta incluir **"[ ]"** antes del nombre del arreglo en la **sentencia
delete.**

![](/TheusZero/images/post/POO_C++/37.png)

#### Punteros y Clases

Los punteros son efectivos cuando los encapsulamos en clases porque
podemos controlar su tiempo de vida.

Debemos poner cuidado con la 
**copia baja o copia en profundidad** ya vista
en Java.

![](/TheusZero/images/post/POO_C++/38.png)

#### Punteros en Clases

El constructor crea el arreglo, y el destructor lo borra. 
**De esta forma
pocas cosas pueden salir mal** excepto cuando hacemos una copia de un objeto Student. El
constructor de copia de C++ conduce a problemas.

![](/TheusZero/images/post/POO_C++/39.png)

Por ejemplo, aquí un curso asignado al estudiante X termina en la
lista de cursos del estudiante Y:

![](/TheusZero/images/post/POO_C++/40.png)

#### Paso de parámetros por valor

Cuando usamos paso por valor, la variable local es creada usando el
constructor copia de la clase.

```vim
void foo (Student s) { ….}
// luego usamos
Student Jose;
foo(Jose); // s es inicializado usando Student s(Jose)
```

Esto es importante, **NO creer** que se invoca algo del tipo
```vim
Student s;
s=Jose; 
```

Lo anterior sugiere implementar el constructor copia.

La **acción por omisión del constructor copia y la asignación es copia baja.**

#### Copia en profundidad

Para prevenir este tipo de problemas, creamos un constructor copia que
efectúa una copia en profundidad.

![](/TheusZero/images/post/POO_C++/41.png)

#### Punteros en Clases

Por la misma razón, tenemos que sobrecargar (overload) el operador de
asignación.


>Regla de ORO:
>> Si una clase requiere un
>> constructor copia, también
>> requerirá la sobrecarga del
>> operador asignación e
>> implementación del
>> destructor.

![](/TheusZero/images/post/POO_C++/42.png)

#### Contenedores C++ en Clases

**Cuando usamos contenedores estándares de C++** como listas
y vectores
en una clase, **no hay problema 
con el constructor de copia** porque todos
ellos implementan adecuadamente el 
constructor copia, la asignación y el
destructor.

```vim
class Student {
public:
 Student();
private:
 vector<string> courses;
};
```

## Desarrollo en Qt

Qt (pronunciado como ¸cute”) es un framework de desarrollo de aplicaciones con
multiples bibliotecas

Creado por Haavard Nord y Erick Chambe-Eng en 1995 (primer release)
Desarrollado sobre C++ inicialmente, pero en la actualidad es posible utilizarlo en
otros lenguajes (Ej: PyQt para Python).

Provee mejoras a las bibliotecas nativas de C++ y permite que c´odigos desarrollados
sobre estas bibliotecas sean compatibles con m´ultiples plataformas (mismo concepto
que se aplicaba en Java).

![](/TheusZero/images/post/POO_C++/43.png)

El codigo se construye sobre bibliotecas Qt y sus distintas herramientas de desarrollo

Estas a su vez generan una abstraccion para ejecucion multiplataforma

![](/TheusZero/images/post/POO_C++/44.png)

> Existen dos tipos de modulos en Qt:
> 
> Modulos Core-Essential: Son los que dan forma a Qt. Son parte del desarrollo de estas
> bibliotecas.
>> Ejemplos de modulos core-essential: QtCore, QtGui, QtWidgets, etc.
>
> Modulos add-ons (agregados): Son c´odigos externos al desarrollo de Qt. Depende de
> las contribuciones de usuarios externos activos en el proyecto.
>> Ejemplo de m´odulos add-ons: Qt3D, QtBluetooth, QtSensors, etc

Qt al ser un conjunto de bibliotecas, pueden ser integradas en cualquier IDE que lo
permita. Incluso, es posible compilar programas Qt sin IDE

Qt Creator es un IDE multiplataforma para desarrollo de programas en C++ creado
por el equipo de desarrollo de Qt. Esta orientado principalmente a crear aplicaciones
graficas facilmente utilizando las bibliotecas de desarrollo que provee Qt

> Qt Creator esta compuesto por:
> 
> Editor de texto: Este posee varias funcionalidades, como autocompletado, revision de
> sintaxis, identacion automatica, etc.
> 
> Qt Designer: Para creacion de interfaces graficas de forma sencilla.
>
> Otras funcionalidades (Ej: Debug, conexi´on con sistemas de versionamiento (GIT,
> SVN, otros), etc.)

#### Elementos de Qt en un proyecto

Headers|Sources|Forms|Archivo.pro

![](/TheusZero/images/post/POO_C++/45.png)

![](/TheusZero/images/post/POO_C++/46.png)

![](/TheusZero/images/post/POO_C++/47.png)

![](/TheusZero/images/post/POO_C++/48.png)

![](/TheusZero/images/post/POO_C++/49.png)

![](/TheusZero/images/post/POO_C++/50.png)

#### Signal y Slots

Permiten la comunicaci´on entre objetos de tipo QObject

Una senal (signal) es emitida por un objeto para senalar un evento o cambio de
interes particular ocurre

Una ranura (slot) es un m´etodo que es llamado en respuesta a una se˜nal particular.

Una clase puede tener tanto signals como slots.

![](/TheusZero/images/post/POO_C++/51.png)

> Signal
> 
> Son funciones/metodos de acceso publico que no deben ser implementadas y no
> retornan valores
> 
> Senales son emitidas por un objeto para senalar algun evento de interes (definido por
> el programador).

> Slot
> 
> Son funciones/metodos que pueden ser llamados normalmente. Su unica diferencia es
> que se pueden conectar con signals.
> 
> Un slot es llamado cuando la senal o las senales a las que esta conectado son emitidas

![](/TheusZero/images/post/POO_C++/52.png)

#### Creando GUI

> Qt Widgets
> 
> Equivalente a Node de JavaFX
> 
>>  Permite acceder a los elementos graficos incluidos en las bibliotecas Qt, tanto layouts
>>  como definicion de ventanas, etc.
> 
>  Algunos elementos graficos que heredan de QWidget:
> 
>>  QLabel
> 
>>  QPushButton
> 
>>  QGraphicsLayout
> 
>>  etc

> Clase QPainter
> 
> Permite realizar pintados de bajo nivel de elementos graficos, generalmente sobre
> widgets.
> 
> Su uso comun es dentro del metodo paintEvent de un widget. paintEvent le dice a la
> clase que debe hacer cuando se pinta el widget.

![](/TheusZero/images/post/POO_C++/53.png)

![](/TheusZero/images/post/POO_C++/54.png)

#### QGraphicsView y QGraphicsScene

QPainter es una clase que permite dibujar a muy bajo nivel,
por lo que no permite
crear elementos graficos con muchas propiedades

Podemos crear elementos graficos con mayor autonomia
al crearlos sobre una vista.

QGraphicsView es donde se muestran los elementos graficos.

QGraphicsScene es la clase que controla como se desplegaran.

Una QGraphicsView tiene asociada una 
QGraphicsScene que la controla.

A la vista se le pueden agregar distintos 
elementos graficos (QGraphicsItem) a traves
de la QGraphicsScene.

Los QGraphicsItem agregados pueden 
ser los que provee Qt o personalizados
heredando de QGraphicsItem.

> Ejemplo QGraphicsScene: Pintar un elemento personalizado
> ![](/TheusZero/images/post/POO_C++/55.png)

#### Animaciones

Metodo advance

El metodo “advance” es un metodo slot
de la clase QGraphicsScene y esta asociado
con la actualizacion de items en la escena.

La actualizacion se hace en dos etapas:
En la primera etapa se notifica a 
todos los elementos de la escena que esta va a cambiar
(phase=0)

En la segunda etapa, se notifica a los items
de la escena que se pueden mover
(phase=1).

El metodo advance, al ser llamado,
llama a todos los metodos advance de cada uno de
los elementos QGraphicsItem de la escena

![](/TheusZero/images/post/POO_C++/56.png)

#### Interfaces QML

Qt Quick o QtQuick es el termino
utilizado para una tecnologia de creacion de interfaces de
usuario utilizada en Qt

Es alternativo a QWidget

Se utiliza principalmente en el desarrollo de aplicaciones moviles

> Esta compuesto principalmente por
> 
>> Archivos QML: Archivos de etiquetado tipo JSON para definicion de la interfaz
>
>> JavaScript: Para acciones producidas por la interfaz
>
>> Qt C++: Codigo detras de la logica del programa

#### Licencias de desarrollo Qt

Dependiendo del tipo de producto que se desee desarrollar, Qt se puede usar bajo
diferentes licencias de desarrollo.

Existen dos tipos de licencias de desarrollo:

>> Licencia comercial: Utilizada para desarrollo de aplicaciones de codigo cerrado
> 
>> Licencia GNU Lesser General Public License (LGPL) v3: Licencia utilizada para
> desarrollo de aplicaciones de codigo abierto.
> Ojo ¡Que sean de codigo abierto no quiere decir que no se puedan comercializar!
>
> Qt ademas contiene codigos con licencias especificas asociadas al autor del mismo.
> Cuando se desarrollan aplicaciones con fines comerciales, es critico revisar las licencias
> de las bibliotecas utilizadas (esto bajo cualquier contexto de desarrollo)

## Herencia en C++

#### Motor y ElectricMotor

![](/TheusZero/images/post/POO_C++/57.png)

![](/TheusZero/images/post/POO_C++/58.png)

![](/TheusZero/images/post/POO_C++/59.png)

#### Creación de Clases Derivadas

![](/TheusZero/images/post/POO_C++/60.png)

![](/TheusZero/images/post/POO_C++/61.png)

#### Inicialización de Clase Base

Para inicializar los atributos definidos en la clase base se llama al
constructor de la clase base. En este ejemplo, el número ID del motor
es pasado al constructor de CMotor.

![](/TheusZero/images/post/POO_C++/62.png)

#### Llamando a métodos de la clase base

![](/TheusZero/images/post/POO_C++/63.png)

#### Función o método Display

La función Display funciona de la misma manera. Ésta llama a
CMotor::Display primero.

![](/TheusZero/images/post/POO_C++/64.png)

#### Probando Clases

Cuando el mismo nombre de método existe en ambas clases, **C++ llama
al método implementado para la clase según la declaración del objeto.**
Éste es el caso con los métodos Input y Display (es lo esperable):

```vim
CElectricMotor elec; // CelectricMotor
elec.Input(); // CElectricMotor
elec.Display(); // CElectricMotor
```

#### Asignación de Objetos

Podemos asignar objetos de clases derivadas a un objeto de la clase
base. Similar a Java aunque esto no exista en Java (porque los nombres
son referencias).

![](/TheusZero/images/post/POO_C++/65.png)

Pero no podemos asignar una instancia de una clase base a una instancia
de una clase derivada (similar restricción en Java). Algunos campos de la
clase derivada no existen en la clase base. 

![](/TheusZero/images/post/POO_C++/66.png)

#### Acceso a miembros Protected (Protegidos)

Miembros de una clase designados como protected son visibles a ambas:
la clase actual y las clases derivadas (y a clases amigas -friend- pero a
nadie más). **Es análogo a Java.**

```vim
class CMotor {
public:
 CMotor() { }
 CMotor( const string & id );
protected:
 string get_ID() const;
 void set_ID(const string & s);
//...
}
```

#### Herencia Protegida

Supongamos por un momento que CMotor usa miembros públicos
para todos sus métodos:

```vim
class CMotor {
public:
 CMotor() { }
 CMotor( const string & id );
 string get_ID() const;
 void set_ID(const string & s);
//...
}
```

#### Herencia Protegida

Podemos usar el calificador **protected** cuando creamos una clase
derivada

Con herencia protegida, todos los **métodos
públicos** en la clase
base **pasan a** ser **protegidos**
en la clase derivada. Los restantes
mantienen su nivel de acceso.

```
class CElectricMotor : protected CMotor {
 //...
};
```

#### Herencia Protegida

Por ejemplo, el programa principal no puede llamar set_ID y get_ID
en un motor eléctrico porque ahora esos métodos son protegidos para
instancias de motor eléctrico.

![](/TheusZero/images/post/POO_C++/67.png)

#### Herencia Privada

La herencia privada causa que todos los métodos declarados en la clase
base tienen acceso privado en la clase derivada.

Pareciera que no hay diferencia con herencia protegida: En ambos casos,
métodos de CElectricMotor pueden acceder a métodos de CMotor

```vim
class CElectricMotor : private CMotor {
 //...
 };
```

#### Herencia Privada

Pero cuando derivamos una nueva clase (CPumpMotor) de
CElectricMotor, la diferencia se hace notar: con herencia privada,
métodos en CPumpMotor no pueden acceder a miembros públicos de
CMotor.

```vim
class CPumpMotor : public CElectricMotor {
public:
 void Display() {
     CMotor::Display(); // not accessible!
     CElectricMotor::Display(); // this is OK
 }
};
```

#### Miembros que no son heredados

El constructor y destructor de la clase base no son heredados, deben ser
definidos en la clase heredada.

El constructor por omisión y el destructor sí son llamados cuando se crea
o destruye una instancia de la clase derivada.

Si la clase base tiene sobrecargado el operador =, éste no se hereda en la
clase derivada.

La relación de “amistad” no se hereda. Las clases y funciones friend no
son friend en la clase hija.

Si se omite el nivel de acceso en clases, equivale a poner private

struct es una palabra reservada que puede ser usada en lugar de la
palabra reservada class. La principal diferencia es que al omitir el
nivel de acceso, se entiende público y no privado como con class.

## Polimorfismo en C++, ligado dinámico y Métodos Virtuales, Casting, Declaración incompleta de clases

#### Jerarquía de clases Motor

Recordemos la jerarquía de clases establecida para el estudio
sobre Herencia:

![](/TheusZero/images/post/POO_C++/68.png)

#### Clase CMotor

La definición de la clase CMotor:
```vim
class CMotor {
public:
   CMotor() { }
   CMotor( const string & id );
   string get_ID() const;
   void set_ID(const string & s);
   void Display() const;
   void Input();
private:
   string m_sID;
}; 
```

#### Clase CElectricMotor

![](/TheusZero/images/post/POO_C++/69.png)

#### Clase CGasMotor

![](/TheusZero/images/post/POO_C++/70.png)

#### Punteros a objetos de clases derivadas y referencias a objetos derivados

Es fácil definir objetos dinámicos de una clase derivada usando
un puntero de tipo específico:

![](/TheusZero/images/post/POO_C++/71.png)

#### Polimorfismo

Análogo a Java, en C++ podemos declarar punteros a una clase base, y
luego asignarle la dirección de una instancia de una clase derivada. **Este
caso es normal en Java.** Es el principio de sustitución en C++. Esta
técnica es un tipo de polimorfismo.

*Recordar: Polimorfismo es un concepto donde, en una de sus
formas, un mismo nombre puede referirse a objetos de clases
diferentes que están relacionadas por una clase base común.*

```vim
CMotor * pM;
 pM = new CElectricMotor; // puntero a motor eléctrico
 // semántica similar a Java
 CElectricMotor em;
 CMotor & motor = em; // referencia a motor eléctrico
 // esta opción no existe en Java
```

![](/TheusZero/images/post/POO_C++/72.png)

#### Ligado dinámico

En C++ la opción por **omisión
es llamar el método definido por el tipo del
puntero o referencia**,
no el tipo del objeto apuntado. Esto es **Distinto a
Java!**

![](/TheusZero/images/post/POO_C++/73.png)

#### Métodos Virtuales (Virtual)

**Si deseamos tener un comportamiento como Java, debemos declarar
los métodos Input y Display como virtuales en la clase base.**

El calificador virtual le dice al compilador que genere código que mire al
tipo del objeto apuntado (no del puntero) en tiempo de ejecución y use
esta información para seleccionar la versión apropiada del método.

El ligado dinámico **aplica cuando usamos punteros o referencias** a
objetos.

```vim
class CMotor {

 virtual void Display() const; // el calificador virtual cambia
 virtual void Input(); // la forma de definir el código
 // a ser finalmente invocado.

};
```

#### Métodos Virtuales

Es recomendable definir también como virtuales los métodos en la
clase derivada, en este caso en las clases CGasMotor y
CElectricMotor.

```vim
class CGasMotor :public CMotor {
public:
 ...
 virtual void Display() const;
 virtual void Input();
 ...
};
```

De esta forma la semántica del método se mantiene entre clases
heredadas.

Ahora los métodos Display e Input son llamados usando ligado
**dinámico** desde la clase CElectricMotor:

```vim
CMotor * pM;
pM = new CElectricMotor;

pM->Input(); // CElectricMotor::Input()
pM->Display(); // CElectricMotor::Display()
```

#### Métodos Virtuales

A menudo, un puntero será pasado como argumento a una función
que espera un puntero a objeto de la clase base.

Cuando el método es llamado, podemos pasar cualquier puntero como
parámetro actual, siempre y cuando éste apunte a una instancia
derivada de la clase base (“subtipo”).

![](/TheusZero/images/post/POO_C++/74.png)

Ejemplo de llamados a GetAndShowMotor con diferentes tipos de
punteros.

![](/TheusZero/images/post/POO_C++/75.png)

#### (Salida de la lámina previa)

![](/TheusZero/images/post/POO_C++/76.png)

#### Creación de un vector de Motores

![](/TheusZero/images/post/POO_C++/77.png)

#### Acceso a Vector de punteros

La función que despliega tales vectores no necesita saber
exactamente qué tipo de puntero están en el vector mientras se
llame a métodos virtuales.

![](/TheusZero/images/post/POO_C++/78.png)

#### Salida de la función ShowVector

La función ShowVector llama a la versión apropiada del método
virtual Display() para cada puntero en el vector.

```vim
------- Vector of Motor Pointers -------
1: [ElectricMotor] ID=10000, Voltage=110
2: [GasMotor] ID=20000, Cylinders=4
3: [ElectricMotor] ID=30000, Voltage=220
4: [GasMotor] ID=40000, Cylinders=2
```

#### Liberación de almacenamiento

Debemos liberar el almacenamiento usado por cada objeto motor.
Este bucle remueve los punteros uno por uno.

```vim
for(int i=0; i < vMotors.size(); i++) {
    delete vMotors[i]; // delete each motor
}
```

El operador delete accede a información que le permite saber
exactamente cuánto almacenamiento liberar por cada puntero (aún
cuando los motores ocupan distintos tamaños).

> Saber distinguir lo previo de:
> ```vim
> CMotor * motor = new CMotor [40];
> delete [] motor; // aquí el arreglo está en el heap.
> ```

#### Métodos Virtuales Puros

Un método virtual puro no tiene implementación. Esto es identificado en
C++ con un "= 0" al final de la declaración

Un método virtual puro **requiere** que la función sea implementada en la
clase derivada.

> Es **equivalente a los métodos abstractos en Java**
> 
> ```vim
> class CMotor {
> public:
> //...
>   virtual void Display() const = 0; // => no está implementado
>   virtual void Input() = 0; // => no está implementado
> //...
> }
> ```

#### Clases Abstractas (Abstract Classes)

Una clase que contiene uno o más métodos **virtuales** puros pasa a
ser una clase **abstracta**.

Por igual razón que en Java, NO es posible crear instancias de una
clase abstracta, pero en **C++ no requiere calificador “abstract”.**

```vim
Con la declaración previa para CMotor:
CMotor M; // error
CMotor * pM = new CMotor; // error
```

#### Conversiones Implícitas datos

C++ maneja conversiones automáticamente en el caso de tipos
numéricos intrínsecos (int, double, float)

> Mensajes de advertencia (warning) pueden aparecer cuando hay
> riesgo de pérdida de información (precisión).
>
> Hay variaciones de un compilador a otro

**Ejemplos**

![](/TheusZero/images/post/POO_C++/79.png)

#### Operación cast

Una operación de “casteo” cast convierte explícitamente datos de un
tipo a otro.

Es usado en conversiones “seguras” que podrían ser hechas por el
compilador. 

Son usadas para abolir mensajes de advertencia (warning
messages).

El operador tradicional de C pone el nuevo tipo de dato entre
paréntesis. C++ mejora esto con una operador cast tipo función.

**Ejemplos de cast**

![](/TheusZero/images/post/POO_C++/80.png)

#### Nueva forma de hacer “casteo” en C++: **static_cast<> y dynamic_cast<>**

El operador static_cast<> es la forma preferida para hacer
conversiones “seguras” en C++

Éste reemplaza el operador tradicional de C y el estilo función de
C++.

Existe también el dynamic_cast<>, éste asegura que el resultado
de la conversión es un dato compatible. Sólo se aplica a punteros
a objetos.

dynamic_cast<> lanza error cuando el resultado de la conversión
no es un objeto completo de la clase requerida.

#### Ejemplos de static_ y dynamic_cast

> static_cast
> ![](/TheusZero/images/post/POO_C++/81.png)

> dynamic_cast
> ![](/TheusZero/images/post/POO_C++/82.png)

#### Declaración incompleta de clases

En ocasiones podemos tener este tipo de dependencias:

![](/TheusZero/images/post/POO_C++/83.png)

![](/TheusZero/images/post/POO_C++/84.png)

![](/TheusZero/images/post/POO_C++/85.png)

## Licencias de Software

#### ¿Que es una licencia de software?

Es un acuerdo legal entre el creador de un software y su usuario
que limita las cosas permitidas hacer

> Una licencia de software responde preguntas como:
> 
> ¿Donde, como y que tan frecuentemente puedo instalar el
> programa?
> 
> ¿Puedo copiarlo, modificarlo o redistribuirlo?
> 
> ¿Puedo mirar su codigo fuente?

No cumplir con este acuerdo legal corresponde a una infraccion
a la ley de derechos de autor

#### ¿Que son los derechos de autor?

Protege los derechos que un autor adquiere sobre la creaci´on de
una obra.

> Existen tres tipos de derechos de autor:
> 
> ![](/TheusZero/images/post/POO_C++/86.png)

#### Tipos de licencias

Algunas de las licencias m´as populares en la actualidad son:

> Sin licencia: Codigos sin licencia tienen copyright por omision.
> Usuarios no tienen derecho a usar el codigo sin permiso explıcito
> de su autor.

> Propietaria: Licencias mas restrictivas, las cuales solo permiten
> el uso de un programa, pero no su modificacion o redistribucion.
> Ej. MS Reference.

> GNU GPLv3: Permisos de utilizacion o modificacion del codigo,
> deben venir acompanadas con la liberacion del nuevo codigo
> fuente generado. Posee copyleft

> GNU LGPLv3: Licencia utilizada por Qt. Identica a la GNU
> 
> GPLv3. Proyectos que utilicen un codigo bajo esta licencia solo
> como biblioteca dinamica, pueden saltarse el copyleft y licenciar
> bajo licencias mas restrictivas.

> MIT License: Licencia permisiva. Utilizar codigo bajo esta
> licencia en un proyecto, solo requiere que se incluya una
> notificacion de la licencia utilizada dentro del software.
> 
> WTFPL: Licencia mas permisiva. “Haz lo que te de la gana”.

#### Uso de licencias

Determinar inicialmente bajo que modalidad quieres licenciar tu
software. Esto determinara que herramientas puedes utilizar y
cuales no.

Tanto para el lenguaje utilizado como para las bibliotecas
incluidas en tu desarrollo, verificar las licencias de cada una y la
compatibilidad con tu modalidad de licencia.

Verificar la compatibilidad de licencias entre los distintos
elementos de tu software. Pueden haber bibliotecas con licencias
incompatibles entre si.

Que algo sea codigo abierto ¡NO quiere decir que sea gratuito!
Ej: Red Hat Linux

Ante cualquier duda, siempre consultar con un abogado.


## Preguntas Certamenes

#### preguntas importantes

**importante**
> ¿Muestre la parte de la implementación de Persona que permite asignar el valor del atributo RUT a un objeto
> instancia de Persona?
>> ![](/TheusZero/images/post/POO_C++/94.png)

**importante**
> Mencione y explique una diferencia de las siguientes dos declaraciones:
> ![](/TheusZero/images/post/POO_C++/89.png)

**importante**
>En java usamos super(...) para invocar un constructor de la clase base. ¿Cómo se hace esto en C++?
>> En la lista de inicialización se debe pone el nombre de la clase con los parámetros del constructor que
>> se desea invocar.

**importante**
> En java usamos super.metodo(..) para invocar un método de la clase base que hemos redefinido en la clase
> derivada. ¿Cómo se hace esta invocación en C++? Dé un ejemplo.
>> Se usa el nombre de la clase base seguida del método como en:
>> ClaseBase::metodo(...)

**importante**
> ¿Cuál es el propósito del calificador “friend”?
>> El calificador friend permite otorgar visibilidad a otras clases o funciones globales de todos los atributos
>> privados o protegidos de una clase.

**importante**
> ¿Cuál es la relación entre clases protegidas, privadas y el calificador Friend? Dé un ejemplo simple.
>> La relación es que una clase o función global pueden acceder a atributos o métodos privados o
>> protegidos de una clase cuando ésta ha declarado como friend a esa clase o función.
>> ![](/TheusZero/images/post/POO_C++/91.png)

**importante**
> Se tiene la función: void foo( A a);
> Cuando ésta es invocada como en foo(mi_a), con mi_a instancia de la clase A, ¿Cómo a toma el valor de
> mi_a? Muestre un código equivalente para ese paso de valor si usted tuviera que crear la variable a y asignarle
> el valor.
>> Corresponde a la creación de la variable local a a partir del constructor copia. El código puesto por el
>> compilador equivale a:
> 
>> A a(mi_a);

> ¿En qué caso usted debe considerar implementar el constructor copia, el destructor y el operador
> asignación? Explique su respuesta.
>> Se debe hacer cada vez que una clase contenga atributos punteros. En este caso es necesario pues el
>> compilador implementa “copia baja” en la asignación y constructor copia por omisión. Además si la clase
>> posee atributos punteros, se debe considerar la devolución de la zona de memoria apuntada por ese puntero
>> y evitar así una fuga de memoria.

**importante**
> Muestre una implementación jerárquica de clases en C++, use una clase Animales como base y
> genere clases derivadas a partir de Animales.
>> Hay múltiples soluciones, no se especifica un mínimo. La correcta creación de la clase Animales y
>> dos derivadas de ella basta. Una solución posible (más completa) es la siguiente.
>> ```vim
>> class Animales {
>> private:
>>  double peso;
>> public:
>>  Animales (double pesoNacer);
>>  virtual void Display() const;
>> };
>> Animales::Animales(double pn) {
>>  peso = pn;
>> }
>> Animales::Display() const {
>>  cout << “Peso:” << peso << endl;
>> }
>> class Gato:public Animales {
>> private:
>>  string nombre;
>> public:
>>  Gato(double p, string n);
>>  virtual void Display() const;
>> };
>> Gato::Gato(double p, string n):Animales(p){
>>  nombre=n;
>> }
>> void Gato::Display() const {
>>  cout << nombre << “es un Gato”<< endl;
>>  Animales::Display();
>> }
>> class Perro:public Animales {
>> private:
>>  string: raza;
>> public:
>>  Perro(double p, string r);
>>  virtual void Display() const;
>> };
>> Perro::Perro(double p, string r):Animales(p) {
>>  raza = r;
>> }
>> Perro::Display() const {
>>  cout << “Perro de raza:”<<raza<<endl;
>>  Animales::Display();
>> }
>> ```
>
> Describa los calificadores de acceso usados en las clases derivadas. Justifique por qué se usaron en
> su ejemplo de la pregunta anterior.
>> Si entendemos esta pregunta como los calificadores de acceso usados en los métodos y atributos de
>> las clase derivadas, éstos son los mismos que pueden usarse en clases bases.
>> En las clases previas he usado los calificadores public y private. Miembros públicos de una clase
>> pueden ser accedidos desde cualquier parte del código. Miembros privados sólo son accesibles
>> desde implementaciones de la misma clase.
>
>> Si entendemos la pregunta como los calificadores de acceso usados al crear una clase derivada, éste
>> es sólo public en este caso. Esto significa que la visibilidad de los métodos de la clase Animales se
>> mantiene para instancias de Gato o Perro.
>> Nota: una de las dos interpretaciones es suficiente para acreditar puntaje completo.
>
> Muestre el uso de un constructor con parámetros y explique la diferencia con un constructor por
> omisión. Haga que su constructor inicialice algún atributo en la clase base Animales.
>> ![](/TheusZero/images/post/POO_C++/93.png)
>
> Utilice y describa el uso de mutadores y accesores al hacer una instanciación de jerarquía de animales.
>> Un mutador es un método que modifica el estado de un objeto (cambia alguno de sus atributos). Un
>> accesor es un método que sólo accede a valores sin modificar el estado del objeto.
>> En el ejemplo de Animales Displaye es un método accesor.
> 
>¿Qué es sobre carga de operadores? Dé un ejemplo de uso en su jerarquía de Animales.
>> La sobrecarga de operadores es la definición que hacemos en una clase para usar instancias de la
>> clase como operandos de algunos operadores.
>> Ejemplo: Si deseamos comparar Animales según su peso, podemos dar sentido al operador <
>> agregando como método de la clase:
> 
>> bool operator<(const Animales&a) const;
> 
>> Y podemos implementarlo comparando su peso:
> 
>> bool Animales::operator<(const Animales &a ) const {
>> return peso < a.peso;
>> }

> En la clase adjunta, ¿Cómo se asigna un valor inicial al atributo a_name?
> class A { public: static string a_name; …..};
>>En la implementación de la clase, archivo .cpp, incluir: string A::a_name= “Asignatura ELO329”


> Explique y dé ejemplos simples del uso de Static en Datos y Funciones.
>> Un atributo estático es aquel compartido por todos los miembros de la clase. Puede ser entendido
>> como un atributo de la clase (o categoría de objetos) y no de un objeto o instancia particular.
>> Una función o método estático son aquellas comunes a todos las instancias de una clase y no
>> dependen de atributos específicos de una instancia. Pueden manipular sólo atributos estáticos.
>> Tanto los datos (atributos) como las funciones (métodos) estáticas pueden ser accedidas con el
>> nombre de la clase o un el de un objeto.
>> Nota: Para obtener máximo puntaje basta con mencionar algunos de los elementos previos.
>> Ejemplo: caso de atributo estático y función estática.
>
>> ![](/TheusZero/images/post/POO_C++/92.png)

> Explique por qué al sobrecargar el operador << , para permitir salida de objetos hacia cout, estamos
> obligados a hacerlo como función global.
>> Pues sólo así podemos usar la sintaxis habitual para salida de datos, como en:
>> cout << objeto;
>> Si la sobrecarga la hiciéramos como método dentro de la clase del objeto, la sintaxis sería:
>> objeto << cout; // no respeta interpretación habitual de operador.
>> La opción de incluir el método dentro de la clase ostream se descarta por tratarse de una clase
>> estándar del lenguaje

> ¿Qué diferencias existen entre ocupar una estructura (struct Student) o una clase (class Student) en un
> programa C++?
>> Sólo una, con clases por omisión los atributos y métodos son privados, con estructuras por omisión
>> éstos son públicos.

> Por qué se recomienda partir los archivos de encabezados con algo del tipo:
> "#ifndef MI_ENCABEZADO"
> "#define MI_ENCEBEZADO"
>> La idea es evitar incluir más de una vez cada archivo. La definición debe ser única dentro del proyecto de
>> manera que una vez incluido un archivo esa definición bloquee repeticiones de ésta. Así el compilador no
>> reportará errores de doble definiciones.

**importante**
> ¿Bajo qué condiciones usted está obligado a implementar el destructor? ¿Qué otros métodos deben
> ser implementados adicionalmente?
>> Cuando la clase posee atributos alojados en espacios de memoria asignados dinámicamente que
>> deben ser retornados al sistema.
>> Otros métodos a implementar en estos casos son: operador de asignación y constructor copia

> ¿Qué diferencia hace el definir un método como virtual?
>> Un método virtual permite que su redefinición en clases derivadas sean ligadas dinámicamente. Su
>> ausencia evita el ligado dinámico, con lo cual en tiempo de ejecución se ejecuta el método según la
>> declaración de la referencia y no según el objeto referenciado.

> Mencione dos ventajas de la metodología de desarrollo iterativa e incremental.
>> Es posible mostrar al cliente versiones parciales del sistema y así validar el desarrollo.
>> Cada etapa permite entender mejor la naturaleza del problema y hacer las mejoras o correcciones
>> necesarias a tiempo

> Se tiene una clase con prototipo foo(ClaseA a); Señale qué método(s) se invoca(n) para que el argumento a
> tome el valor del parámetro “objeto” usado en la invocación foo(objeto).
>> Para inicializar a, se usa el constructor como en: ClaseA a(objeto);

> ¿Cuál es la razón de existencia o propósito de las certificaciones de software?
>> El propósito de las certificaciones de software es dar información a los clientes sobre cuán riguroso es el
>> proceso seguido por una empresa para generar software de calidad

> ¿Qué es un caso de uso? ¿Para qué sirve?
>> Un caso de uso es una secuencia de acciones donde interactúa un usuario con el sistema a desarrollar
>> para mostrar una funcionalidad específica del sistema.
>> Los casos de uso sirven para definir requerimientos del sistema y luego son usados en las etapas de
>> análisis y al final para hacer las pruebas unitarias

> En C++ se tiene la función foo con el siguiente prototipo:
> int foo(Student s);
>> Al invocar la función con int i=foo(juan); Indique el constructor invocado para crear el objeto s y cómo éste
>> adopta el valor del parámetro actual.
>> Se invoca el constructor copia Student(const Student & s). Al invocar foo(juan), el objeto s se inicializa
>> con s(juan);

> fuga de memoria:
> 
> ![](/TheusZero/images/post/POO_C++/95.png)

> Mencione dos usos para la palabra reservada const y por qué en C++ no fue posible invocar al
> constructor de clase base usando palabra reservada super de Java.
>> Usos de const: Para declarar una variable como constante y para declarar que un método no modifica el
>> estado de un objeto.
> 
>> No se puso usar super porque en C++ una clase puede heredar de más de una clase base. Por esto en C++
>> debemos invocar el constructor de la clase base usando el nombre de ésta.


#### preguntas extras

> Alguien dice que los actores de un caso de uso siempre son personas. Diga si es verdadero o falso y
> justifique.
>> Falso, actores de un sistema también pueden ser sensores o módulos de software externos al sistema
>> bajo desarrollo.

> ¿Qué es un método virtual puro? ¿Para qué se sirven?
> Es un método virtual sin implementación en la clase base, lo cual se indica con =0 al final del prototipo del
> método.
>> Sirven para listar métodos en la clase base que sólo tiene sentido implementar en las clases derivadas.
>> Es necesario listarlos en la clase base para crear código donde usamos punteros o referencias de la
>> clase base para invocar esos métodos y así crear código reusable

> ¿Qué problema de los lenguajes no orientados a objetos explica la incorporación del manejo de excepciones
> de los lenguajes orientados a objetos?
>> En los lenguajes no orientados a objetos las situaciones de error de ejecución deben ser tratadas en cada
>> parte donde éstas puedan ocurrir. Esto extiende el código que cumple la funcionalidades deseadas en
>> muchas líneas preocupadas de las condiciones de error. Como consecuencia, aumenta la dificultad para
>> depurar y mantener el código. Las excepciones permiten separar el código fundamental del tratamiento
>> de todas las condiciones de error.

> ¿Cuáles con son los requerimientos funcionales? Dé un ejemplo de requerimiento no funcional.
> Los requerimientos funcionales describen el comportamiento de un sistema ante determinadas
> entradas.
>> Un ejemplo de comportamiento no funcional es el lenguaje a usar (también el desempeño del
>> sistema, -tiempo de ejecución, tamaño de código)

>¿Quiénes nos son los actores en un caso de uso?
>> Los actores son los entes externos que interactúan con el sistema

> Mencione 3 ventajas de las metodologías de desarrollo de software iterativas e incrementales.
>> Permite generar versiones ejecutables parciales para evaluación del cliente.
> 
>> Permite identificar prontamente condiciones no especificadas en los requerimientos.
> 
>> Permite una mejor gestión de proyecto identificando la proporción de casos de uso cubiertos en el tiempo

> En orden mencione las actividades desarrolladas en cada iteración de la metodología iterativa e
> incremental.
>> Definición de requerimientos, análisis, diseño, implementación, pruebas y distribución.

> ¿Cuál es el propósito de los diagramas de secuencia definidos en UML?
>> Su propósito es mostrar las relaciones dinámicas entre objetos que interactúan

> Presente alguna situación donde la sobrecarga de operadores debe hacerse o conviene hacerla vía funciones
> globales y no vía métodos de una clase.
>> Cuando no podemos modificar la clase donde se debe implementar la sobrecarga; por ejemplo, cuando
>> deseamos enviar a hacia una salida serial del tipo cout una objeto instancia de una de nuestras clases

> Mencione una operación válida en una aplicación Java pero no en un applet (a menos que sea firmada).
>> Las aplicaciones Java pueden escribir en disco local, un applet no.

> Mencione desventajas de la metodología de desarrollo de software en “cascada” frente al “iterativo e incremental”.
>>  “Cascada” no contempla obtener avances parciales ejecutables del sistema para ser validados por el
>>  cliente.
> 
>>  “Cascada” dificulta la identificación oportuna de problemas, por ejemplo derivados de una errada
>>  definición de requerimiento.
> 
>>  “Cascada” no facilita como “iterativo e incremental” el entendimiento del problema en la medida que el
>>  sistema se desarrolla

> Mencione dos objetivos buscados por las metodologías de desarrollo de software.
> Ayuda: ¿Da lo mismo usar o no una metodología de desarrollo de software? Como no da lo mismo, ¿qué se
> busca con el uso de una metodología de desarrollo de software?
>> Se busca mantener los desarrollos de software dentro de los tiempo y costos acordados con el cliente y
>> además cumplir adecuadamente con los requerimientos.

> ![](/TheusZero/images/post/POO_C++/90.png)

> ¿Cuál es la diferencia entre funciones out of line e in line? ¿Por qué la diferencia?
>> La diferencia sintáctica está en su implementación. Si se hace directamente en la declaración de la
>> clase se dice in-line. Si se hace en un fuera de la declaración de la clase se dice out-of-line.
>> Las funciones in-line permiten optimizar el código generado cuando las implementaciones son de
>> pocas líneas.
>> Nota: en caso de código in-line, el compilador no genera salto a la implementación de la función,
>> sino inserta su implementación en el lugar donde el método es llamado. 

> Si en una entrevista de trabajo a usted le preguntan qué es la Ingeniería de Software ¿qué diría?
>> La ingeniería de software es una disciplina dedicada al diseño, construcción y mantención de programas
>> computacionales eficientes, económicos que logran cumplir sus objetivos en tiempos definidos.

> Además de “identificar una oportunidad de negocio” y “levantamiento inicial de requerimientos”, mencione 4
> otras etapas de un proyecto de software.
>> Confección de propuesta, Análisis del problema, Definición de la arquitectura, Diseño de la solución,
>> Codificación de la solución, Pruebas Unitarias, Pruebas de Integración, Capacitación de los usuarios, Marcha
>> blanca, Puesta en producción.

> Mencione un tipo de diagrama UML de estructura y un tipo de diagrama UML de comportamiento.
>> Diagrama de estructura: Diagrama de clases.
>> Diagrama de comportamiento: Diagrama de secuencia, diagrama de estados.

> Indique qué elemento diferenciador agrega cada uno de los 3 niveles superiores de certificación CMM
> (Modelo de Madurez de la Capacidad) respecto del previo. Ej. Nivel 2 es capaz de repetir éxitos previos (esto
> no lo hace el nivel 1).
>> Nivel 3 tiene un proceso definido que no tiene el Nivel 2.
>> Nivel 4 incorpora mediciones a la ejecución del proceso y así puede verificar su correcta ejecución.
>> Nivel 5 es capaz de identificar mejoras del proceso permitiendo así la mejora continua.

> Mencione dos ventajas de crear archivos .h y .cpp independientes para cada clase de un proyecto respecto de
> usar un único archivo que incluya los encabezados y las implementaciones.
>>Facilita la reutilización de código pues así puedo reutilizar clases específicas en otros proyectos.
>
>> Permite una compilación más eficiente pues ante un cambio es preciso recompilar sólo la parte que fue modificada

> ¿Bajo qué condición y con qué fin se recomienda implementar un método dentro de la declaración de su clase
> (conocido como función miembro o método in-line)?
>> Se recomienda hacer esto cuando el código del método es pequeño. Esto se hace con el propósito de obtener
>> un código más rápido debido a que en cada llamado a ese método el compilador pondrá el código del mismo
>> en lugar de un llamado a éste. Con esto se logra mantener el pipeline de ejecución de los procesadores
>> modernos

> Explique qué caracteriza una organización con certificación CMM nivel 1 y otra de nivel 4.
>> CMM nivel 1: la organización no tiene definido procesos ni utiliza al experiencia previa, el resultado obtenido
>> depende de la calidad de cada individuo.
> 
>> CMM nivel 4: La empresa tiene procesos bien definidos y efectúa mediciones que le permiten controlar la
>> calidad de sus resultados los cuales son predecibles

> ¿Qué es un patrón de diseño?
>> Un patrón de diseño es una solución general reusable a un problema común recurrente

> ¿Qué situación hace necesario el uso de declaraciones incompletas de clases (también conocidas como
> forward declarations)? Dé un ejemplo.
>> Las declaraciones incompletas de una clase son necesarias cuando hay referencias circulares entre clases.
>> Esto ocurre cuando una clase A usa objetos de la clase B, la clase B usa objetos de la clase C y la clase C
>> usa objetos de la clase A. A → B → C → A.
>> En esta situación los archivos de encabezados generan una dependencia circular que el preprocesador no
>> puede resolver.
>> La solución es usar una referencia incompleta, por ejemplo, de la clase C (class C;) y no ocupar su archivo
>> de encabezado.
>> Un ejemplo se presentó en tarea 3. En etapa 1, Ball ocupa un puntero a MyWorld y MyWorld ocupa un
>> puntero a Ball. 

> ¿Qué ventaja tiene la separación de una clase C++ en un archivo de encabezado y otro de
> implementación en lugar de hacer todo junto?
>> Se gana velocidad de compilación evitar error por doble implementación de clase.
>> Para que un código compile sólo se requiere tener declarada todas las clases que en él se ocupan. Sus
>> implementaciones sólo son necesarias a la hora de ligar todos los módulos para generar el ejecutable.
>> Si usamos todo junto, cada vez que compilemos un código se estará compilando la implementación de las
>> clases usadas. Si una clase es usada en más de un archivo, además no podremos generar el ejecutable por
>> presencia de implementaciones repetidas.



